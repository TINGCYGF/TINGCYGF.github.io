<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tingcygf.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Javascript是运行在客户端的脚本语言（Script是脚本的意思） 脚本语言：不需要编译，由js解释器逐行进行解析并执行 现在可以基于Node.js技术进行服务器编程">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript基础知识总结笔记">
<meta property="og:url" content="https://tingcygf.github.io/2020/02/09/05JavaScript%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Ting的博客平台">
<meta property="og:description" content="Javascript是运行在客户端的脚本语言（Script是脚本的意思） 脚本语言：不需要编译，由js解释器逐行进行解析并执行 现在可以基于Node.js技术进行服务器编程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1708982/202004/1708982-20200405191000886-1768397487.png">
<meta property="article:published_time" content="2020-02-09T03:12:26.000Z">
<meta property="article:modified_time" content="2020-10-26T06:57:42.000Z">
<meta property="article:author" content="Ting">
<meta property="article:tag" content="前端总结">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2020.cnblogs.com/blog/1708982/202004/1708982-20200405191000886-1768397487.png">

<link rel="canonical" href="https://tingcygf.github.io/2020/02/09/05JavaScript%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript基础知识总结笔记 | Ting的博客平台</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ting的博客平台</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tingcygf.github.io/2020/02/09/05JavaScript%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ting.png">
      <meta itemprop="name" content="Ting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ting的博客平台">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript基础知识总结笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-09 11:12:26" itemprop="dateCreated datePublished" datetime="2020-02-09T11:12:26+08:00">2020-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-26 14:57:42" itemprop="dateModified" datetime="2020-10-26T14:57:42+08:00">2020-10-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Javascript是运行在客户端的脚本语言（Script是脚本的意思）</p>
<p>脚本语言：不需要编译，由js解释器逐行进行解析并执行</p>
<p>现在可以基于Node.js技术进行服务器编程</p>
<a id="more"></a>

<h2 id="初识-JavaScript"><a href="#初识-JavaScript" class="headerlink" title="初识 JavaScript"></a>初识 JavaScript</h2><p>Javascript是运行在客户端的脚本语言（Script是脚本的意思）</p>
<p>脚本语言：不需要编译，由js解释器逐行进行解析并执行</p>
<p>现在可以基于Node.js技术进行服务器编程</p>
<p>ps：js中使用单引号</p>
<p>JavaScript 是<strong>区分大小写</strong>的，并使用 <strong>Unicode</strong> 字符集。举个例子，可以将单词 Früh （在德语中意思是“早”）用作变量名</p>
<h3 id="浏览器执行JS过程"><a href="#浏览器执行JS过程" class="headerlink" title="浏览器执行JS过程"></a>浏览器执行JS过程</h3><p>浏览器分为渲染引擎和JS引擎</p>
<p>渲染引擎：解析HTML与CSS，俗称内核，如chrome的blink</p>
<p>主流浏览器（必须有独立内核）市场份额大于3%<br>内核名称<br>IE : trident<br>chrome : webkit/blink<br>firefox : gecko<br>opera : presto<br>safari : webkit</p>
<p>JS引擎：读取网页在JavaScript代码并运行，如chrome的V8</p>
<h3 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h3><ol>
<li>ECMAScript（基础语法）：由ECMA国际标准化的一门语言。</li>
<li>DOM（文档对象模型）</li>
<li>BOM（浏览器对象模型）</li>
</ol>
<h3 id="JavaScript三种方式"><a href="#JavaScript三种方式" class="headerlink" title="JavaScript三种方式"></a>JavaScript三种方式</h3><ol>
<li>行内式：&lt;   &gt;</li>
<li>内嵌式：<script></script></li>
<li>外部式: <script src='**.js'></script></li>
</ol>
<h3 id="JavaScript输入输出语句"><a href="#JavaScript输入输出语句" class="headerlink" title="JavaScript输入输出语句"></a>JavaScript输入输出语句</h3><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">alert（msg）</td>
<td align="center">浏览器弹出警示框</td>
</tr>
<tr>
<td align="center">console.log（msg）</td>
<td align="center">浏览器控制台打印输出信息</td>
</tr>
<tr>
<td align="center">prompt（info）</td>
<td align="center">浏览器弹出输入框可以输入</td>
</tr>
</tbody></table>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>•    所谓标识符，就是指变量、函数、属性的名字，或函数的参数。<br>•    标识符可以是按照下列格式规则组合起来的一或多个字符：<br>–    第一个字符必须是一个字母、下划线（ _ ）或一个美元符号（ $ ）。<br>–    其他字符可以是字母、下划线、美元符号或数字。<br>•    按照惯例，ECMAScript 标识符采用驼峰命名法。<br>•    但是要注意的是JavaScript中的标识符不能是关键字和保留字符。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是存放数据的<strong>容器</strong>，通过<strong>变量名</strong>获取数据</p>
<p>本质：变量是程序内申请存放数据的空间</p>
<ul>
<li>声明多个变量：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myname = <span class="string">'ting'</span>,</span><br><span class="line">    age = <span class="number">18</span>,</span><br><span class="line">    big = <span class="number">66</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明变量特殊情况</li>
</ul>
<table>
<thead>
<tr>
<th align="center">只声明不赋值</th>
<th align="center">undefind</th>
</tr>
</thead>
<tbody><tr>
<td align="center">不声明不赋值</td>
<td align="center">报错</td>
</tr>
<tr>
<td align="center">不声明只赋值</td>
<td align="center">正常输出（全局变量）</td>
</tr>
</tbody></table>
<ul>
<li>变量命名规范<ul>
<li>由字母、数组、下划线、$符号组成</li>
<li>区分大小写</li>
<li>不能以数字开头</li>
<li>不能是关键字：var、for</li>
<li>变量名必须有意义</li>
<li>遵守驼峰命名法。首字母小写，后单词大写：myFirstName</li>
</ul>
</li>
</ul>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>运算大于赋值的优先级</strong><br>js是动态语言，动态语言基本上都是解释性语言，解释性语言基本上都是脚本语言。<br>js是浮点型语言（带小数点）。</p>
<ul>
<li><p>原数据（stack栈),先进后出。</p>
</li>
<li><p>引用值（heap堆数据）大致上放堆heap里面</p>
<ul>
<li>array数组, Object, function … data,RegExp正则。</li>
</ul>
</li>
</ul>
<p>引用值是把第一个值放到第二个值里面，改第一个值，第二个值也改变</p>
<p>js由值决定类型。原始值和引用值唯一的不同是赋值形式不同</p>
<h3 id="语句基本规则"><a href="#语句基本规则" class="headerlink" title="语句基本规则"></a>语句基本规则</h3><ul>
<li><p>语句后面要用分号结束“；</p>
</li>
<li><p>但function test(){}，for(){}，if(){}后面都不用加分号</p>
</li>
<li><p>“= + / -”两边都应该有空格</p>
</li>
</ul>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>我们程序由一条条语句构成的，在js中可以运用{ }称为代码块，可以统一执行或不执行</p>
<p>代码块结束不用分号；代码块仅有分组作用</p>
<h4 id="代码错误"><a href="#代码错误" class="headerlink" title="代码错误"></a>代码错误</h4><p>错误分为两种</p>
<ul>
<li>低级错误（语法解析错误），不能写中文</li>
<li>逻辑错误（标准错误，情有可原，错的那个执行不了）</li>
</ul>
<p>代码错误只会影响当前代码块会终止，不影响下面代码块</p>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><h4 id="运算操作符"><a href="#运算操作符" class="headerlink" title="运算操作符"></a>运算操作符</h4><ul>
<li>“+”作用：数学运算、字符串链接 </li>
<li>任何数据类型加字符串都等于字符串</li>
<li>使用加空串可以隐式转化为字符串</li>
<li>除了加法，其余运算符都先转化为数字再运算</li>
<li>可以运用+a转化为数字</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = “a”+ <span class="literal">true</span> + <span class="number">1</span>; <span class="comment">//打印atrue1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + “a” + <span class="number">1</span> + <span class="number">1</span>; <span class="comment">//打印1a11</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">1</span> + “a” + <span class="number">1</span> + <span class="number">1</span>; <span class="comment">//打印2a11，从左向右运算</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">1</span> + “a” +( <span class="number">1</span> + <span class="number">2</span>); <span class="comment">//打印2a3</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span> + <span class="string">""</span>; <span class="comment">//使用加空串可以隐式转化为字符串</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span> / <span class="number">0</span>； <span class="comment">//答案是NaN，应该得出一个数字类型的数，但是没法表达，就用NaN (NaN是Not a Number非数，不是数，但是是数字类型</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> / <span class="number">0</span>; <span class="comment">//是infinity（无限）</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">-1</span> / <span class="number">0</span>; <span class="regexp">/是-infinity（负无限）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>%，摩尔，模，是取余数的意思</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">5</span>%<span class="number">2</span> <span class="comment">//5%2是五除二的余数，商二余一</span></span><br><span class="line"><span class="keyword">var</span> a =<span class="number">5</span>%<span class="number">1</span> <span class="comment">//是五除一的余数，结果是0</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span> % <span class="number">5</span>; <span class="comment">//意思是1除以5的余数。商0余1</span></span><br><span class="line"><span class="keyword">var</span> a =<span class="number">4</span>%<span class="number">6</span> <span class="comment">//是四除六的余数，结果是4</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;a % = <span class="number">5</span>;<span class="built_in">document</span>.write(a); <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;a % = <span class="number">5</span>;<span class="built_in">document</span>.write(a); <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;a %= <span class="number">2</span>;<span class="built_in">document</span>.write(a); <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;a % = <span class="number">4</span>; <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>“-”，“*”，“/“，“%”，”=“，“()” 优先级”=“最弱【赋值符号优先级最低】，”()”优先级较高</p>
</li>
<li><p>“++”，“- -”，”+=“，“-=”，“/=“，“*=”，“%=” ++</p>
</li>
</ul>
<p><strong><u>运算符优先级不用记，分不清只需要添加括号加权</u></strong></p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><ul>
<li><p>“&gt;”，”&lt;”，”==”，“&gt;=”，“&lt;=”，”!=”</p>
</li>
<li><p>比较结果为boolean值</p>
</li>
<li><p>但凡是运算符，都是要有运算的</p>
</li>
<li><p>用到布尔值，true或false</p>
</li>
<li><p>字符串的比较，比的是ASCII码（七位二进制0000000）</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"10"</span>&gt;<span class="string">"8"</span>;<span class="built_in">document</span>.write(a); <span class="comment">//答案false</span></span><br><span class="line"><span class="comment">//不是十和八比，是字符串一零和八比，先用开头的一和八比，比不过就不看第二位了；一样的就拿零和八比</span></span><br></pre></td></tr></table></figure>

<p>对于非数值比较式，将会转换为数字进行比较</p>
<p>转换为数字后，如何转换为NaN的比较都为false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"10"</span> &lt; <span class="number">8</span>;<span class="built_in">document</span>.write(a); <span class="comment">//答案false</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">8</span>  &lt; <span class="string">"hello"</span>; <span class="built_in">document</span>.write(a); <span class="comment">//答案false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>= =， ！=等不等于</li>
<li>会做数据转换再比较</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">//答案是false，NaN不等于任何东西，包括他自己</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span> == underfined; <span class="comment">//答案是true</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">//答案是true</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span> == <span class="number">0</span>; <span class="comment">//答案是false，null不是转为数字</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"1"</span> == <span class="literal">true</span>; <span class="comment">//答案是true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>=== </li>
<li>！==</li>
</ul>
<p>全等于不会做类型转换，类型不同直接返回false</p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>“&amp;&amp;”，“||”，“!“运算结果为真实的值 </p>
<ul>
<li>“&amp;&amp;”与运算符</li>
</ul>
<p>有假即输出0，全真输出最后一个表达式的值</p>
<p>可以用于判断，先判断是否为真然后输出最后值</p>
<p>如果第一个值为false，则直接返回第一个原稿值</p>
<p>如果第一个值为true，则直接返回第二个值原值</p>
<ul>
<li>&amp;与运算 我们一般不用</li>
</ul>
<p>转化为二进制，相同为1，不同为0</p>
<ul>
<li>“||”或运算符</li>
</ul>
<p>全假才为假，有一个真就为真</p>
<p>如果第一个值为true，则直接返回第一个原稿值</p>
<p>如果第一个值为false，则直接返回第二个值原值</p>
<ul>
<li>“!“非运算符</li>
</ul>
<p>先转成布尔值，再取反</p>
<p>被认定为false的值：转换为布尔值会被认定为false的值undefined， null， NaN， “”（空串）， 0， false</p>
<p><strong>可以！！a作为隐式转化</strong></p>
<h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><p>语法：{ 条件表达式？语句1：语句2；}</p>
<p>条件表达式求值为true则执行语句1，否则执行语句2</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &gt; b ? alert(<span class="string">"比较大"</span>)：alert(<span class="string">"b大"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><h4 id="If语句"><a href="#If语句" class="headerlink" title="If语句"></a>If语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件判断)&#123;</span><br><span class="line">	当条件成立时，执行里面的执行语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当if的条件成立时，才能执行{}内的语句</p>
<p>当条件转化为布尔值，如果为true就执行；如果为false就不执行</p>
<p>&amp;&amp;放在if中的，全真才为真，&amp;&amp;是并且的意思</p>
<p>||放在if中是或者的意思，有一个是真就可以了</p>
<p><strong>不能写90&lt;score&lt;100</strong>,这样写会先比90&lt;score,等于true以后再跟100比</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(scor &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(score + <span class="string">'优秀学生'</span>)	;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>else if</p>
<p>满足了第一条就不看第二条了</p>
</li>
</ul>
<p>用else if要满足条件与条件之间互斥，不能有交叉点。除了上面所有以外的。else if除了这个以外，满足第一个就不看了，不满足就看后面的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &gt;= <span class="number">90</span> &amp;&amp; sccre &lt;=<span class="number">100</span>)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'优秀'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">90</span> &amp;&amp; score &gt;= <span class="number">60</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'及格'</span>)；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &lt; <span class="number">60</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'不及格'</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch case"></a>switch case</h4><p>if(条件判断)</p>
<p>switch(条件){ case 写条件：里面判是否相符： </p>
<p>​        如果相符合就执行case后面的语句</p>
<p>switch不负责任，如果判断了a是符合条件的，也会把后面的连带打印出来<br>加个break，就可以终止语句</p>
<p>switch找到满足要求的语句后，后面的语句虽然不判断了，但是也会执行出来<br>加个break，就可以终止swich case语句</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(date)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"monday"</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"周一"</span>)；</span><br><span class="line">        <span class="keyword">break</span>；</span><br><span class="line">     <span class="keyword">case</span> <span class="string">"tuesday"</span>:</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"周二"</span>)；</span><br><span class="line">        <span class="keyword">break</span>；</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"其他"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (只执行一次; 判断; 判断成立后执行语句) &#123;</span><br><span class="line">	判断成立后执行；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	<span class="built_in">document</span>.write(‘a’)；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行顺序如下：</span></span><br><span class="line"><span class="keyword">var</span> i= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i &lt;<span class="number">10</span>)&#123;</span><br><span class="line"><span class="built_in">document</span>.write(‘a’)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &lt;<span class="number">10</span>)&#123;</span><br><span class="line"><span class="built_in">document</span>.write(‘a’)</span><br><span class="line">&#125;</span><br><span class="line">i++</span><br></pre></td></tr></table></figure>

<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while循环是for循环的简化版for( ； ； ){}</p>
<p>while循环底层机制是for循环</p>
<p>for ( ; 只在这一部分写，前后不写 ; ){}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（判断语句)&#123;</span><br><span class="line">	判断成立执行语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a>do while循环</h4><p>do while是不管满不满足条件都会先执行一次，再判断成不成立，如果成立才会执行第二次，不成立就停止 一般没人用</p>
<h4 id="back"><a href="#back" class="headerlink" title="back"></a>back</h4><p>break的标准定义是终止循环，break必须要放在循环里面 switch, for,while都是循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>；</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	sum += i;</span><br><span class="line">	<span class="keyword">if</span>(sum &gt; <span class="number">100</span>) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>终止本次循环，后面的都不执行了，来进行下一次的循环</p>
<p>当i是7的倍数的时候，不打印</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span>(i % <span class="number">7</span> == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul>
<li>简单数据类型</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Number</th>
<th align="center">数字类型：包括整型和浮点型</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Boolean</td>
<td align="center">布尔值：true，false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">字符串类型</td>
<td align="center">“”</td>
</tr>
<tr>
<td align="center">Undefined</td>
<td align="center">声明后没赋值</td>
<td align="center">undefined</td>
</tr>
<tr>
<td align="center">Null</td>
<td align="center">空值,空对象</td>
<td align="center">null</td>
</tr>
</tbody></table>
<ul>
<li><p>数字类型中</p>
<ul>
<li>数字前面加0代表八进制</li>
<li>数字前面加0x代表十六进制</li>
<li>最大值：Number.MAX_VALUE</li>
<li>最小值：Number.MIN_VALUE</li>
<li>lnfinity：代表无穷大</li>
<li>-lnfinity：无穷小</li>
<li>NaN：非数值</li>
<li>isNan()  :用来判断是否为数值，返回true  /  false</li>
</ul>
</li>
<li><p>字符串类型</p>
<ul>
<li>字符串嵌套，外单内双 “ 我 ’ 是 ‘ 谁 ”</li>
<li>字符串转义符：</li>
</ul>
<p>转义符都是  \   开头 ，  并且都在引号中</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">\n</th>
<th align="center">换行   newline</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\\</td>
<td align="center">\</td>
</tr>
<tr>
<td align="center">\‘    \“</td>
<td align="center">’  “</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">tab缩进</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">空格   blank</td>
</tr>
</tbody></table>
<h2 id="进制赋值"><a href="#进制赋值" class="headerlink" title="进制赋值"></a>进制赋值</h2><p>表示16进制，以0x开头</p>
<p>表示8进制，以0开头</p>
<p>表示2进制，以0b开头</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0xff</span>；</span><br><span class="line">a = <span class="number">066</span>；</span><br><span class="line">a = <span class="number">0</span>b555；</span><br><span class="line"><span class="comment">//有些浏览器不支持所以少用</span></span><br></pre></td></tr></table></figure>

<h2 id="引用值"><a href="#引用值" class="headerlink" title="引用值"></a>引用值</h2><p>基本数据类型和引用数据类型的区别</p>
<p>JS中的变量都是保持在栈内存中</p>
<ol>
<li>基本数据类型只是单纯保持在栈中</li>
<li>引用数据类型会创建一个堆内存中的引用空间。所以添加属性是在堆空间中添加。栈中保存的变量只是对应堆的地址。</li>
</ol>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>var arr = [1,2,3,4,5,6,7,”abc”,undefined];</code><br>arr [0] 代表查数组的第一位，因为数字是从0开始的算的<br>arr [0] = 3; 是指把数组的第一位改成3，显示3,2,3,4,5,6,7, ”abc”,undefined<br>arr.length;是数组的长度，有多少位就有多少<br><code>console.log(arr.length); //答案是 8位</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用for循环把数组中的每一位都拿出来——遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象object"><a href="#对象object" class="headerlink" title="对象object"></a>对象object</h3><p>面向对象的编程方法 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">	里面存属性和方法</span><br><span class="line">    key属性名：value属性值;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在{}面用。属性与属性之间用逗号隔开 //属性值可以双引号或单引号；属性名是为了方便找到他，只是一个辅助</p>
<p>1.面向过程，如c<br>第一步干嘛，第二步干嘛 </p>
<p>2.面向对象（对象object）<br>现在js是一半面向过程，一半面向对象，前面学的都是面向过程</p>
<h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>typeof能返回的六种数据类型（区分数字类型）</p>
<p>number、string、boolean、undefined、object、function</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num)); <span class="comment">//返回number</span></span><br><span class="line"><span class="comment">//写成console.log(typeof num );也可以不过最好加括号</span></span><br><span class="line"><span class="keyword">var</span> num = &#123;&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num)); <span class="comment">//泛泛的引入值都返回object</span></span><br><span class="line"><span class="keyword">var</span> num = [];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num)); <span class="comment">//泛泛的引入值都返回object</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num)); <span class="comment">//答案null返回object，最早是代替空对象的</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num)); <span class="comment">//答案返回undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h4 id="Number-mix"><a href="#Number-mix" class="headerlink" title="Number(mix)"></a>Number(mix)</h4><p>把里面的东西转换成数字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(‘<span class="number">123</span>’);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示Number:123，把字符串类型的123转换成了number类型</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(‘abd’);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示Number:NaN</span></span><br><span class="line"><span class="keyword">var</span> demo = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(demo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示Number:NaN</span></span><br><span class="line"><span class="keyword">var</span> demo = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(demo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示Number:0</span></span><br></pre></td></tr></table></figure>

<h4 id="parseInt-string-radix"><a href="#parseInt-string-radix" class="headerlink" title="parseInt(string,radix)"></a>parseInt(string,radix)</h4><p>parse是转化，Int是整型，整数，目的是把里面转换成整数</p>
<p>radix代表进制（取值2~36）如2进制转为10进制，若strin=3，则得到NaN</p>
<p>radix写成16，系统会认为是以16进制为基底， 10（一零）是16进制的一零，是以16进制为基底，把他转成为10进制的数字（就是16），上面是以目标进制为基底，转换成十进制（radix范围是2-36）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(demo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示number: NaN</span></span><br><span class="line"><span class="keyword">var</span> demo = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(demo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示number: NaN</span></span><br><span class="line"><span class="keyword">var</span> demo = <span class="number">123.9</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(demo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示number: 123，此处是直接去掉小数，不是四舍五入</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = “<span class="number">3</span>”;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(demo ,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示number: NaN</span></span><br><span class="line"><span class="keyword">var</span> demo = <span class="number">123</span>abd112;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(demo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示number: 123，此处是直接去掉abd直接保留前面数字</span></span><br></pre></td></tr></table></figure>

<h4 id="parseFloat-string"><a href="#parseFloat-string" class="headerlink" title="parseFloat(string)"></a>parseFloat(string)</h4><p>parseFloat(string)转换成浮点数字，就是正常小数</p>
<p>parseFloat从数字类开始看，看到除了第一个点以外的非数字类为截止，返回前面的数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = “<span class="number">100.2</span>abc”;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseFloat</span> (demo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示number: 100.2 parseFloat从数字类开始</span></span><br></pre></td></tr></table></figure>

<h4 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h4><p>想把谁转换成字符串，就写成谁.toString，上面是想把demo转换成toString，写成demo.toString</p>
<p>该方法不会改变原变量，所以需要赋值</p>
<p>undefined和null不能用toString</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> num = demo.toString();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示string: 123。相当于把123转换字符串。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> num = demo.toString(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案173，把123转成为八进制</span></span><br><span class="line"><span class="comment">//这里的radix意思是以十进制为基底，转换成目标进制（即8进制）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给你一个二进制的数，转换成十六进制，是先从二进制到十进制再到十六进制</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10101010</span>;</span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">parseInt</span>(num, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test.toString(<span class="number">16</span>));</span><br></pre></td></tr></table></figure>

<h4 id="String-mix-函数"><a href="#String-mix-函数" class="headerlink" title="String(mix)函数"></a>String(mix)函数</h4><p>String(mix)转换成字符串，写什么都成了字符串</p>
<p>String和toString都是调用toString方法，但是undefined和null不能用toString。</p>
<p>所以null和undefined直接转成字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">String</span> (demo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示string: undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="Boolean-mix"><a href="#Boolean-mix" class="headerlink" title="Boolean(mix)"></a>Boolean(mix)</h4><p>Boolean()转换成布尔值false和true</p>
<p>数字除了0和NaN，其余都转成true</p>
<p>字符串除了空串“”，都是true</p>
<p>null和undefined转成false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = “”;</span><br><span class="line"><span class="keyword">var</span> num =  <span class="built_in">Boolean</span>(demo);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “:” + num);</span><br><span class="line"><span class="comment">//答案显示boolean: false</span></span><br></pre></td></tr></table></figure>

<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换是跟你转换了也不知道 </p>
<p>隐式类型转换内部隐式调用的是显示的方法</p>
<p>隐式类型转换包括isNaN () ，++，–， +/-（一元正负），+，*，% ，，&amp;&amp;，|| ，！，&lt;，&gt;，&lt;= ，&gt;= ，== ，!=</p>
<h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN ()"></a>isNaN ()</h4><p>isNaN ();当你把一个数放到()里，它能判断是不是NaN，先比括号里面的放到number里面转换，然后返回来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">//答案true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(“<span class="number">123</span>”); <span class="comment">//答案false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(“abc”); <span class="comment">//答案true。会调用number，先把“abc”放number里面转换，通过number的转换再和NaN比对，如果相等就是true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">null</span>); <span class="comment">//答案false，在number里面放null是0，不是NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">undefined</span>); <span class="comment">//答案true</span></span><br></pre></td></tr></table></figure>

<h4 id="–、-、-和"><a href="#–、-、-和" class="headerlink" title="++/–、 +/- 、*和%"></a>++/–、 +/- 、*和%</h4><p>乘和模都会转换成number.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例<span class="keyword">var</span> a = “abc”;</span><br><span class="line">a ++;</span><br><span class="line">答案<span class="literal">NaN</span></span><br><span class="line">++这个符号放到这里，还没运算之前，先把前面的abc转换成number</span><br></pre></td></tr></table></figure>

<h4 id="amp-amp-！"><a href="#amp-amp-！" class="headerlink" title="&amp;&amp;      ||     ！"></a>&amp;&amp;      ||     ！</h4><p>与或非，都是有类型转换的，不过是返回的是表达式的值，不是隐士类型转换的值，但是判断是一个类型转换的值</p>
<h4 id="lt-gt-lt-gt"><a href="#lt-gt-lt-gt" class="headerlink" title="&lt; &gt; &lt;= &gt;="></a>&lt; &gt; &lt;= &gt;=</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="number">1</span> &gt; “<span class="number">2</span>”; <span class="built_in">console</span>.log(a + “:” + <span class="keyword">typeof</span>(a));</span><br><span class="line"><span class="comment">//答案false:boolean，有数字相比较的，就会隐士类型转换成数字类型</span></span><br><span class="line"><span class="keyword">var</span> a =”<span class="number">3</span>” &gt; “<span class="number">2</span>”; <span class="built_in">console</span>.log(a + “:” + <span class="keyword">typeof</span>(a));</span><br><span class="line"><span class="comment">//答案这个没类型转换，这个比的是ASCⅡ</span></span><br><span class="line"><span class="keyword">var</span> a =”<span class="number">3</span>” &gt; <span class="number">2</span>; <span class="built_in">console</span>.log(a + “:” + <span class="keyword">typeof</span>(a));</span><br><span class="line"><span class="comment">//答案true：boolean会转换成数字，因为数字优先</span></span><br></pre></td></tr></table></figure>

<h4 id="、"><a href="#、" class="headerlink" title="==、 !="></a>==、 !=</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> == “<span class="number">1</span>”; <span class="built_in">console</span>.log(a + “:” + <span class="keyword">typeof</span>(a));</span><br><span class="line"><span class="comment">//答案true:boolean，也有隐士类型转换</span></span><br><span class="line"><span class="number">2</span>&gt;<span class="number">3</span>&lt;<span class="number">1</span> <span class="comment">//答案true</span></span><br><span class="line">挨个算的，先看前面的是<span class="literal">true</span>还是<span class="literal">false</span>，再和后面的比，不是顺着下来</span><br><span class="line">例<span class="literal">undefined</span>&gt;<span class="number">0</span> <span class="comment">//答案false</span></span><br><span class="line">例<span class="literal">undefined</span>==<span class="number">0</span> <span class="comment">//答案false</span></span><br><span class="line">例<span class="literal">undefined</span>&lt;<span class="number">0</span> <span class="comment">//答案false</span></span><br><span class="line">例<span class="literal">null</span>&gt;<span class="number">0</span> <span class="comment">//答案false</span></span><br><span class="line">例<span class="literal">null</span>==<span class="number">0</span> <span class="comment">//答案false</span></span><br><span class="line">例<span class="literal">null</span>&lt;<span class="number">0</span> <span class="comment">//答案false</span></span><br><span class="line">例<span class="literal">undefined</span> == <span class="literal">null</span> <span class="comment">//答案true</span></span><br><span class="line">例<span class="literal">NaN</span> ==<span class="literal">NaN</span> <span class="comment">//答案false，NaN是唯一一个连自己都不等于的</span></span><br></pre></td></tr></table></figure>

<h3 id="不发生类型转换"><a href="#不发生类型转换" class="headerlink" title="不发生类型转换"></a>不发生类型转换</h3><p>===、!==</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> !== “<span class="number">1</span>” <span class="comment">//答案true</span></span><br><span class="line"><span class="literal">NaN</span> =<span class="literal">NaN</span> <span class="comment">//答案false特殊的</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//如果定量没定义就直接访问，就a is not defined报错；有一种特殊情况，当且仅当把未定义的变量放到</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a));里面就访问，不报错，返回<span class="literal">undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(a)); <span class="comment">//答案undefined，这个undefined是字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">typeof</span>(a))); <span class="comment">//答案string。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="keyword">typeof</span>(a)));可以先解析成<span class="built_in">console</span>.log(<span class="keyword">typeof</span>(“<span class="literal">undefined</span>”));再返回一次就是string字符串 上面考的是<span class="keyword">typeof</span>(a)返回的六种类型的值（number、string、boolean、<span class="literal">undefined</span>、object、<span class="function"><span class="keyword">function</span>）都是<span class="title">undefined</span>字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="函数function"><a href="#函数function" class="headerlink" title="函数function"></a>函数function</h2><p><code>function 随便起个名(){}</code></p>
<p>写了一个test（）；就执行了一遍函数语句，如果不写test（）；就相当于有一个框来存东西，但是不执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(‘hello world’); </span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义一个函数可以先写一个function,函数就是另一个类型的变量<br>我声明一个函数test,test是函数名。写成下面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	函数体 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数名起名：开发规范要求，函数名和变量名如果由多个单词拼接，必须符合小驼峰原则（第一个单词首字母小写，后面的首字母大写）</p>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>命名函数表达式</p>
<p>上面这个函数的函数名name是abc</p>
<p>在控制台console直接输出test就会出现→</p>
<p>在控制台console直接输出abc会报错，表达式就会忽略他的名字abc。</p>
<p>在上面例子中，<code>fuction abc(){document.write(‘a’);}</code>这一部分叫表达式，是会忽略abc这个地方的名字，会变成匿名函数表达式，不如直接写成匿名函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	documen.write(<span class="string">"我是函数表达式"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名函数表达式</p>
<p>匿名函数表达式（常用，一般说的函数表达式就是匿名函数表达式）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	documen.write(<span class="string">"我是函数声明"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> abc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	documen.write(<span class="string">"我是函数表达式"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>function test(){}其中function是函数关键字，test是函数名，必须有(){}，参数可有可没有，参数是写在()括号里面的。</p>
<p>如果写成function test(a，b){}，相当于隐式的在函数里面var a，var b申明了两个变量，（）括号里面不能直接写var</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>(1)形参（形式参数）：指的是function sum（a，b）{}括号里面的a和b</p>
<p>(2)实参（实际参数）：指的是sum（1，2）；里面的1，2</p>
<p>天生不定参，形参可以比实参多，实参也可以比形参多</p>
<p>js参数不限制位置，天生不定参数 在每一个函数里面都有一个隐式的东西arguments这个是实参列表</p>
<p>console.log();是把信息展示在控制台<br>document.write();<code>是把信息展示到网页</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//arguments--实参列表[数组]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//答案[11, 2, 3]，3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c, d</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(sum.length);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//形参长度求法 4</span></span><br></pre></td></tr></table></figure>

<p>arguments里面一个变，一个跟着变，但是[a,b]是两个人，相当于映射关系。</p>
<p>没有实参的b就无法改变值。</p>
<p>实参列表出生时有几个，就有几个，在写b=4，也不加在arguments[1]里面了，此处的b就当变量用，他和实参不映射。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">num</span>（<span class="title">a</span>， <span class="title">b</span>）</span>&#123;</span><br><span class="line">	a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a);</span><br><span class="line">	<span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">	b = <span class="number">4</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line">num(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//答案：3	4  undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="返回值return"><a href="#返回值return" class="headerlink" title="返回值return"></a>返回值return</h3><p>结束条件和返回值return，return有终止函数的功能</p>
<p>没写return，实际上是加上了一个隐式的return</p>
<p>return最常用的是返回值。本意是把一个值返回到函数以外</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把target转成数字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNumber</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> +target; <span class="comment">//利用+隐式的转换成了数字类型</span></span><br><span class="line">	<span class="built_in">console</span>.log(target)<span class="comment">//return下面不再执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = myNumber(‘<span class="number">123</span>’);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(num) + “” + num);</span><br><span class="line">答案number <span class="number">123</span></span><br></pre></td></tr></table></figure>

<h2 id="js运行三部曲"><a href="#js运行三部曲" class="headerlink" title="js运行三部曲"></a>js运行三部曲</h2><p>1语法分析 → 2预编译 → 3解释执行</p>
<h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>函数声明整体提升：</p>
<p>函数不管写到哪里，都会被提到逻辑的最前面。所以不管在哪里调用，本质上都是在后面调用</p>
<p>变量 声明提升：</p>
<p>把var a提升到最前面，var a = 123;这是变量声明再赋值。<br>变量 声明提升是把他拆分成var a; a = 123;然后把var a提升到最前面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面这两句话没办法解决下面例子的问题</span></span><br><span class="line">unction a(a)&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">234</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a =<span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>函数声明前就会提前预编译，但是函数表达式不能提前创建</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我会被提前创建"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我不会在声明前预编译”);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量就为全局对象(就是window)所有。</p>
<p>一切声明的全局变量，全是window的属性。</p>
<p>window就是全局的域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = b = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>写test()代表执行test，赋值是自右向左的，上面先把123赋给b的时候，b未经声明，然后再声明a，再b的值赋给a，导致b未经声明，所以b归window所有<br>访问window.a是undefined，访问window.b是123</p>
<h3 id="（函数）预编译的四部曲"><a href="#（函数）预编译的四部曲" class="headerlink" title="（函数）预编译的四部曲"></a>（函数）预编译的四部曲</h3><p>1.创建AO对象Activation Object(执行期上下文，作用是理解的作用域，函数产生的执行空间库)</p>
<p> 2.找形参和变量声明，将变量和形参名作为AO属性名，值为undefined 相当于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AO&#123;</span><br><span class="line">	a : <span class="literal">undefined</span>,</span><br><span class="line">    b : <span class="literal">undefined</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.将实参值和形参统一（把实参值传到形参里）</p>
<p> 4.在函数体里面找函数声明，值赋予函数体 （先看自己的AO，再看全局的GO）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a , b</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">234</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line">a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">b = <span class="number">234</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test(1); 一旦有重名的，一但有a变量又有a函数【如function a ()&#123;&#125;】，又在第一条访问的是a，一定是函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//答题过程： 将变量和形参名作为AO属性名，AO&#123;</span></span><br><span class="line">a : <span class="literal">undefined</span>,</span><br><span class="line">b : <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">将实参值和形参统一，AO&#123;</span><br><span class="line">a : <span class="number">1</span>,</span><br><span class="line">b : <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">找函数声明<span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;，AO&#123;</span><br><span class="line">a : <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">b : <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">执行<span class="built_in">console</span>.log(a);答案是<span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">执行<span class="built_in">console</span>.log(b);答案是<span class="literal">undefined</span></span><br><span class="line">执行<span class="keyword">var</span> b = <span class="number">234</span>;变AO&#123;</span><br><span class="line">a : <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">b : <span class="number">234</span></span><br><span class="line">&#125;</span><br><span class="line">执行<span class="built_in">console</span>.log(b);答案是<span class="number">234</span></span><br><span class="line">执行a = <span class="number">123</span>;变AO&#123;</span><br><span class="line">a : <span class="number">123</span>,</span><br><span class="line">b : <span class="number">234</span></span><br><span class="line">&#125;</span><br><span class="line">执行<span class="built_in">console</span>.log(a);答案是<span class="number">123</span></span><br><span class="line">然后<span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;;<span class="keyword">var</span> a ;都可以不看了</span><br><span class="line">执行b = <span class="number">234</span>，b值还是<span class="number">234</span>，不变</span><br><span class="line">执行<span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;，变AO&#123;</span><br><span class="line">a : <span class="number">123</span>,</span><br><span class="line">b : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">执行<span class="built_in">console</span>.log(a);答案是<span class="number">123</span></span><br><span class="line">执行<span class="built_in">console</span>.log(b);答案是<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全局的预编译三部曲"><a href="#全局的预编译三部曲" class="headerlink" title="全局的预编译三部曲"></a>全局的预编译三部曲</h4><p> 1、生成了一个GO的对象Global Object（window就是GO）</p>
<p> 2、找形参和变量声明，将变量和形参名作为GO属性名，值为undefined </p>
<p>3、在函数体里面找函数声明，值赋予函数体</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">答案过程，GO&#123;</span><br><span class="line">a : <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">函数声明GO&#123;</span><br><span class="line">a : <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">执行<span class="keyword">var</span> a = <span class="number">123</span>;变GO&#123;</span><br><span class="line">a : <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行console.log(a);就是123</span></span><br><span class="line"><span class="comment">//GO === window， GO和window是一个东西</span></span><br><span class="line"><span class="comment">//console.log(a);和console.log(window.a);和console.log(go.a);是一样</span></span><br></pre></td></tr></table></figure>

<p>任何全局变量都是window上的属性 </p>
<p>没有声明就是赋值了，归window所有，就是在GO里面预编译</p>
<h4 id="先生成GO还是AO"><a href="#先生成GO还是AO" class="headerlink" title="先生成GO还是AO?"></a>先生成GO还是AO?</h4><p>想执行全局，先生成GO，在执行test的前一刻生成AO </p>
<p>在几层嵌套关系，近的优先，从近的到远的，有AO就看AO，AO没有才看GO</p>
<p>AO上面有就用AO的，没有就看GO的</p>
<h3 id="作用域精解"><a href="#作用域精解" class="headerlink" title="作用域精解"></a>作用域精解</h3><p>作用域定义：变量（变量作用于又称上下文）和函数生效（能被访问）的区域</p>
<p>全局、局部变量</p>
<p>全局作用域中页面打开时创建，在关闭网页时销毁</p>
<p>作用域的访问顺序<br>作用域:函数里面的可以访问外面的全局变量</p>
<p>函数外面不能用函数里面的。里面的可以访问外面的，外面的不能访问里面的，彼此独立的区间不能相互访问</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在函数作用域也有声明提前的特性.使用var关键字声明的变量，会在函数中所有的代码执行之前被声明.函数声明也会在函数中所有的代码执行之前执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fun4();</span><br><span class="line">    <span class="comment">//console.log(a);</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">35</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"I'm fun4"</span>);</span><br><span class="line">&#125;				</span><br><span class="line"><span class="comment">//fun3();		</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">33</span>;</span><br><span class="line"><span class="comment">//在函数中，不用var声明的变量都会成为全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun5</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//console.log("c = "+c);</span></span><br><span class="line"><span class="comment">//c = 10;		</span></span><br><span class="line"><span class="comment">//d没有使用var关键字，则会设置为全局变量</span></span><br><span class="line">				d = <span class="number">100</span>;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>[[scope]]:每个javascript函数都是一个对象，对象中有些属性我们可以访问，但有些不可以，这些属性仅供javascript引擎存取，[[scope]]就是其中一个。[[scope]]指的就是我们所说的作用域,其中存储了运行期上下文的集合。 </p>
<p>作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。 </p>
<p>运行期上下文:当函数在执行的前一刻，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁。</p>
<p>查找变量：在哪个函数里面查找变量，就从哪个函数作用域链的顶端依次向下查找。</p>
<p>函数类对象，我们能访问test.name test.</p>
<p>[[scope]]隐式属性——作用域</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line">理解过程</span><br><span class="line">a被定义 a.[[scope]] → <span class="number">0</span> : GO&#123;&#125;</span><br><span class="line">a被执行 a.[[scope]] → <span class="number">0</span> : aAO&#123;&#125;</span><br><span class="line"><span class="number">1</span> : GO&#123;&#125;</span><br><span class="line">b被定义 b.[[scope]] → <span class="number">0</span> : aAO&#123;&#125;</span><br><span class="line"><span class="number">1</span> : GO&#123;&#125;</span><br><span class="line">b被执行 b.[[scope]] → <span class="number">0</span> : bAO&#123;&#125;</span><br><span class="line"><span class="number">1</span> : aAO&#123;&#125;</span><br><span class="line"><span class="number">2</span> : GO&#123;&#125;</span><br><span class="line">c被定义 c.[[scope]] → <span class="number">0</span> : bAO&#123;&#125;</span><br><span class="line"><span class="number">1</span> : aAO&#123;&#125;</span><br><span class="line"><span class="number">2</span> : GO&#123;&#125;</span><br><span class="line">c被执行 c.[[scope]] → <span class="number">0</span> : cAO&#123;&#125;</span><br><span class="line"><span class="number">1</span> : bAO&#123;&#125;</span><br><span class="line"><span class="number">2</span> : aAO&#123;&#125;</span><br><span class="line"><span class="number">3</span> : GO&#123;&#125;</span><br><span class="line">当c执行完后，会干掉自己的cAO，回到c被定义的状态，当c再被执行时，会生成一个新的newcAO&#123;&#125;，其余都一样，因为基础都是c的被定义状态</span><br><span class="line">c被执行 c.[[scope]] → <span class="number">0</span> : newcAO&#123;&#125;</span><br><span class="line"><span class="number">1</span> : bAO&#123;&#125;</span><br><span class="line"><span class="number">2</span> : aAO&#123;&#125;</span><br><span class="line"><span class="number">3</span> : GO&#123;&#125;</span><br><span class="line">如果<span class="function"><span class="keyword">function</span> <span class="title">a</span>不被执行，下面的<span class="title">function</span> <span class="title">b</span>和<span class="title">function</span> <span class="title">c</span>都是看不到的（也不会被执行，被折叠）。只有<span class="title">function</span> <span class="title">a</span>被执行，才能执行<span class="title">function</span> <span class="title">a</span>里面的内容</span></span><br><span class="line"><span class="function"><span class="title">a</span>(<span class="params"></span>);不执行，根本看不到<span class="title">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;里面的内容</span><br></pre></td></tr></table></figure>

<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>定义：此类函数没有声明，在一次执行过后即释放（被销毁）。适合做初始化工作。 针对初始化功能的函数：只想让它执行一次的函数 立即执行的函数也有参数，也有返回值，有预编译.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="comment">//写成(function abc()&#123;&#125;())也调用不到</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">234</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>

<p>立即执行函数的两种写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;()); <span class="comment">//在W3C建议使用这一种</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;)();</span><br></pre></td></tr></table></figure>

<p>只有表达式才能被执行符号执行<br>能被执行符号执行的表达式，这个函数的名字就会被自动忽略（放弃名字）<br>能被执行符号执行的表达式基本上就是立即执行函数</p>
<p>函数声明和函数表达式是两个东西，虽然都能定义函数</p>
<p>函数声明：function test ( ){} </p>
<p>函数表达式：var test = function( ){}</p>
<p>只有表达式才能被执行符号执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//答案这也是函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="comment">//答案test()；就是表达式，所以能执行</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(‘a’);</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//答案这是表达式，可以被执行，此时在控制台执行test的结果是undefined，这个函数的名字就会被放弃</span></span><br><span class="line">+ <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(‘a’);</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">//答案加了个“正“，在趋势上要把他转换成数字，就是表达式了，既然是表达式就能被执行，就会放弃名字，此时console.log (test)，就会报错；这就是立即执行函数</span></span><br><span class="line"><span class="comment">//同样放了正号，负号，！就会放弃函数名字，转换成表达式；但是*和/不行，&amp;&amp;||前面放东西也行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">a, b, c, d</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a + b + c + d);</span><br><span class="line">&#125;(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">//写成(1)也是这种效果</span></span><br><span class="line"><span class="comment">//理论上不能执行，只写()就会被当成执行符，但是(1, 2, 3, 4);这样写暂时不会当成运算符，没意义，但是不会执行，也不报错。还能调用test</span></span><br></pre></td></tr></table></figure>



<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>当内部函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄露。内存泄漏就是内存占用，内存被占用的越多，内存就变得越来越少了，就像内存被泄露了一样.</p>
<p>但凡是内部的函数被保存到外部，一定生成闭包</p>
<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>实现公有变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">demo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="built_in">console</span>.log(count)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> demo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> counter = add()</span><br><span class="line">counter();</span><br><span class="line"><span class="comment">//实现函数累加器</span></span><br></pre></td></tr></table></figure>

<p>可以做缓存</p>
<p>eg:eater。缓存是外部不可见的，但是确实有存储结构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        num--;</span><br><span class="line">        <span class="built_in">console</span>.log;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [add, min];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = test();</span><br><span class="line">count[<span class="number">0</span>]();</span><br><span class="line">count[<span class="number">1</span>]();</span><br><span class="line"><span class="comment">//答案 101  100</span></span><br></pre></td></tr></table></figure>

<p>可以实现封装</p>
<p>eg: Person();</p>
<p>模块化开发</p>
<p>先定义一个10位数的数组，就是在var arr = [function () {console.log(i);}有十个]并且把数组返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>)</span>&#123; <span class="comment">//定义个函数test</span></span><br><span class="line"><span class="keyword">var</span> arr = []; <span class="comment">//定义一个空数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line"><span class="comment">//丰满空数组，让空数组添加十条数组，</span></span><br><span class="line">每一条都是一个<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//随着for循环i变，</span></span><br><span class="line">数组i也变，arr每一次都等于一个全新的函数体</span><br><span class="line"><span class="built_in">document</span>.write(i + “ ”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr; <span class="comment">//把arr返回到外部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myArr = test();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j ++)&#123;</span><br><span class="line">    <span class="comment">//分别执行十个函数体，函数体里面定义了document.write</span></span><br><span class="line">	myArr[j]();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//答案10 10 10 10 10 10 10 10 10 10</span></span><br></pre></td></tr></table></figure>

<p>函数定义时赋值时都不会解析内部，只有在执行时才会解析</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们让上面这个变成打印0,1,2,3,4,5,6,7,8,9，用立即执行函数解决</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">		(<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">			arr[j] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">document</span>.write( j + “ ”);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(i));</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">var</span> myArr = test();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j ++)&#123;</span><br><span class="line">myArr[j]();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="闭包的防范"><a href="#闭包的防范" class="headerlink" title="闭包的防范"></a>闭包的防范</h3><p>闭包会导致多个执行函数共用一个公有变量，如果不是特殊需要，应尽量防止这种情况发生。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><strong>对象是拥有属性和方法的数据。</strong></p>
<p>属性是与对象相关的值。</p>
<p>方法是能够在对象上执行的动作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myPan = &#123;</span><br><span class="line">    name: <span class="string">"Ting"</span>,</span><br><span class="line">    age: <span class="number">40</span>,</span><br><span class="line">    ageNow： <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myPan.ageNow()</span><br></pre></td></tr></table></figure>

<h3 id="对象的分类"><a href="#对象的分类" class="headerlink" title="对象的分类"></a>对象的分类</h3><ol>
<li><p>内建对象</p>
<p>ES标准中定义的对象</p>
<p>如：Math String Number Boolean Function object…</p>
</li>
<li><p>宿主对象</p>
<p>JS运行环境提供的对象，指由浏览器提供的对象</p>
</li>
<li><p>自定义对象</p>
<p>由开发人员自定义</p>
</li>
</ol>
<h3 id="属性的增、删、改、查"><a href="#属性的增、删、改、查" class="headerlink" title="属性的增、删、改、查"></a>属性的增、删、改、查</h3><p>在上面的基础上myPan.sex = “xiaoliu”<br>也可以在控制台操作=“”等号后面的引号里面需要有值才可以</p>
<p>删除必须借助delete mrDeng.sex</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.sex = “xiaoliu”</span><br><span class="line"><span class="keyword">delete</span> myPan.sex</span><br></pre></td></tr></table></figure>

<p>使用特殊属性名不能采用点.来操作</p>
<p>语法： 对象[“属性名”] = 属性值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj[<span class="string">"123"</span>] = <span class="string">"这是特殊属性名"</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[n]);</span><br></pre></td></tr></table></figure>

<h3 id="对象的创建方法"><a href="#对象的创建方法" class="headerlink" title="对象的创建方法"></a>对象的创建方法</h3><p>(1) <code>var obj = {}</code> 对象字面量/对象直接量plainObject</p>
<p>(2)构造函数</p>
<p> 1)系统自带的构造函数<code>Object()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>();<span class="built_in">Array</span>();<span class="built_in">Number</span>();<span class="built_in">Boolean</span>();<span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>

<p>系统自带的构造函数<code>Object()</code>可以批量生成对象，每一个对象都一样，但是彼此相互独立。<br>在Object()前面加个new，变成new Object()的执行，就会真正的返回一个对象，通过return返回，拿变量接受。var obj = new Object();<br>var obj = new Object();和var obj = {};这样写区别不大</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = ‘abc’;</span><br><span class="line">obj.sex = “male”;</span><br><span class="line"><span class="comment">//双引号和单引号都是表示的字符串，写双引号也可以写单引号，但是为了跟后端php配合最好写单引号。如果要打印一个单个的引号，用正则表达式转义字符\</span></span><br><span class="line"><span class="comment">//注意等号和冒号的用法obj.say = function()&#123;&#125; var obj = &#123; name : ‘abc’&#125;</span></span><br></pre></td></tr></table></figure>

<p>2）自定义</p>
<p>Object.create(原型)方法</p>
<p>必须用new这个操作符，才能构造出对象 构造函数必须要按照大驼峰式命名规则，但凡是构造函数就要大写，例如TheFirNa</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"宝马"</span>；</span><br><span class="line">    <span class="keyword">this</span>.lang = <span class="string">"4000"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="comment">//car1和car是长得一样，但是是不同的两个car。方法名和对象名尽量不一样</span></span><br><span class="line"><span class="comment">//a和A变量是两个变量，var car = new Car里面car和Car是两个变量</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数内部原理"><a href="#构造函数内部原理" class="headerlink" title="构造函数内部原理"></a>构造函数内部原理</h3><p>前提必须要加new，以下三步都是隐式的：</p>
<p>1.在函数体最前面隐式的加上var this = {} 空对象 </p>
<p>2.执行 this.xxx = xxx; </p>
<p>3.隐式的返回return this</p>
<ul>
<li>构造函数是专门用来创建对象的函数<ul>
<li>一个构造函数我们也可以称为一个类</li>
<li>通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例</li>
<li>通过同一个构造函数创建的对象，我们称为一类对象</li>
<li>构造函数就是一个普通的函数，只是他的调用方式不同，<br>如果直接调用，它就是一个普通函数<br>如果使用new来调用，则它就是一个构造函数</li>
<li>构造函数的执行流程：<br>1.创建一个新的对象<br>2.将新的对象作为函数的上下文对象（this）<br>3.执行函数中的代码<br>4.将新建的对象返回</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命名默认大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , gender</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.gender = gender;</span><br><span class="line">	<span class="comment">//向对象中添加一个方法</span></span><br><span class="line">    <span class="comment">//this.sayName = fun;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将sayName方法在全局作用域中定义,将函数定义在全局作用域，污染了全局作用域的命名空间,而且定义在全局作用域中也很不安全</span></span><br><span class="line"><span class="comment">/*function fun()&#123;</span></span><br><span class="line"><span class="comment">	alert("Hello大家好，我是:"+this.name);</span></span><br><span class="line"><span class="comment">	&#125;;*/</span></span><br><span class="line"><span class="comment">//向原型中添加sayName方法</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"Hello大家好，我是:"</span>+<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//创建一个Person的实例</span></span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>,<span class="number">18</span>,<span class="string">"男"</span>);</span><br><span class="line"><span class="keyword">var</span> per2 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>,<span class="number">28</span>,<span class="string">"男"</span>);</span><br><span class="line">per.sayName();</span><br><span class="line">per2.sayName();</span><br><span class="line"><span class="comment">//instanceof 用来检查一个对象是否是一个类的实例</span></span><br><span class="line"><span class="comment">//语法：对象 instanceof 构造函数</span></span><br><span class="line"><span class="comment">//如果该对象时构造函数的实例，则返回true，否则返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(per <span class="keyword">instanceof</span> Person);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(per <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="构造函数注意点"><a href="#构造函数注意点" class="headerlink" title="构造函数注意点"></a>构造函数注意点</h4><p>当构造函数需要运用函数时，需要把函数放到外面，再调用。</p>
<p>因为每次new时都会占用内存，调用则不会只需要调用同一个函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name , age , gender</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.gender = gender;</span><br><span class="line">	<span class="keyword">this</span>.sayName = fun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我是外部函数"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>new String(); new Boolean(); new Number();</p>
<p>var num =123; → 原始值数字 只有原始值数字是原始值，原始值不能有属性和方法</p>
<p>属性和方法只有对象有，包括对象自己，数组，function</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串类型的对象</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> Nunber(<span class="number">123</span>); <span class="comment">//数字类型对象</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(‘abcd’); <span class="comment">//字符串类型对象</span></span><br><span class="line"><span class="keyword">var</span> bol = <span class="keyword">new</span> <span class="built_in">Boolean</span>(‘<span class="literal">true</span>’); <span class="comment">//布尔类型对象</span></span><br><span class="line"><span class="comment">//undefined和null不可以有属性</span></span><br><span class="line"><span class="literal">undefined</span>.abc = <span class="number">123</span>;<span class="comment">//会报错</span></span><br></pre></td></tr></table></figure>

<p>原始值不可能有属性和方法，但经过了包装类(加隐式)可以调用一些属性与方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">4</span>；</span><br><span class="line">num.len = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//系统隐式的加上new Number(4).len = 3; 然后delete</span></span><br><span class="line"><span class="built_in">console</span>.log(num.len);</span><br><span class="line"><span class="comment">//系统隐式的加上new Number(4).len; 但是这个new number和上面的new number不是同一个，所以返回undefined 而上面这些隐式的过程就是包装类</span></span><br><span class="line"><span class="keyword">var</span> str = “abcd”;</span><br><span class="line">str.length = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//隐式的加上new string(‘abcd’).length = 2; delete</span></span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="built_in">console</span>.log(str.length);</span><br><span class="line"><span class="comment">//答案是abcd，4</span></span><br></pre></td></tr></table></figure>

<h3 id="对象枚举"><a href="#对象枚举" class="headerlink" title="对象枚举"></a>对象枚举</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语法： <span class="keyword">for</span>（<span class="keyword">var</span> 变量 <span class="keyword">in</span> 对象）&#123;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ...in 对象有几个属性就循环几遍</span><br><span class="line">每次执行都会将一个属性的名字赋值给变量</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> n <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"属性名："</span> +n)；</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"属性值："</span>+obj[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收（GC）"><a href="#垃圾回收（GC）" class="headerlink" title="垃圾回收（GC）"></a>垃圾回收（GC）</h3><p>就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾</p>
<p>这些垃圾积攒过多以后，会导致程序运行的速度过慢，</p>
<p>所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾</p>
<p>当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，</p>
<p> 此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，</p>
<p> 所以这种垃圾必须进行清理。</p>
<p> 在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，</p>
<p>我们不需要也不能进行垃圾回收的操作</p>
<p>我们需要做的只是要将不再使用的对象设置null即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"> <span class="comment">//对对象进行各种操作。。。。</span></span><br></pre></td></tr></table></figure>

<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ol>
<li>定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。</li>
<li>利用原型特点和概念，可以提取共有属性。</li>
<li>对象属性的增删和原型上属性增删改查。 </li>
<li>象如何查看原型 ==&gt; 隐式属性 <code>__proto__</code>。 </li>
<li>对象如何查看对象的构造函数 <code>==&gt; constructor</code>。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Car.prototype.carName = <span class="string">"BMW"</span>;<span class="comment">//添加属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color, owner</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.owner = owner;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">'red'</span>, <span class="string">'pro.ji'</span>);</span><br></pre></td></tr></table></figure>

<p>下面通过对象（后代）改原型（祖先）是不行的，在对象里面修改，只作用给自己<br>改原型都不行，增加肯定也不行。对象可以删除属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">car.carName = <span class="string">"ting"</span></span><br><span class="line"><span class="comment">//car没有lastName属性会去原型修改</span></span><br><span class="line"><span class="comment">//不推荐这样修改原型</span></span><br><span class="line"><span class="keyword">delete</span> car.carName</span><br><span class="line"><span class="comment">//删除属性，不会删除原型属性</span></span><br></pre></td></tr></table></figure>

<p>原型的作用：提取共同属性，简化写法如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Car.prototype = &#123;</span><br><span class="line">	lang: <span class="number">4900</span>,</span><br><span class="line">	height : <span class="number">1400</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color, owner</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.owner = owner;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">'red'</span>, <span class="string">'pro.ji'</span>);</span><br></pre></td></tr></table></figure>

<p>在原型内部自带constructor，指的是Car。通过constructor能找的谁构造的自己</p>
<p>constructor可以被人工手动更改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">car.constructor</span><br><span class="line"><span class="comment">//function Car()&#123;&#125;</span></span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">	<span class="keyword">constructor</span>: Person</span><br><span class="line">&#125;</span><br><span class="line">//修改<span class="keyword">constructor</span></span><br></pre></td></tr></table></figure>

<p>浅粉色的<code>__proto__</code>是系统的隐式的属性,前面两个<em>后面两个<em>，可以修改，尽量不改。<br>在开发的时候，如果很私人可以写成_private，告诉同事别动。<br><code>__proto__</code>放的是原型。<code>__proto__</code>存的对象的原型<br>`var this ={__proto</em></em>:person.prototype};`这个对象并不是空的，这个proto，当你访问这个对象的属性时，如果对象没有这个属性，那么就会访问proto索引，看看有没有。有一个连接的关系，原型和自己连接到一起</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">car.__proto__ = obj</span><br><span class="line"><span class="comment">//不可修改</span></span><br></pre></td></tr></table></figure>

<p><code>Person.prototype.name</code>这种.的写法是在原有的基础上把值改了。改的是属性，也就是房间里面的东西。<br>而<code>Person.prototype={name:’cherry’}</code>是把原型改了，换了新的对象。改了个房间。<br>在new的时候<code>var this = {__proto__:Person.prototype}</code>里面的指向Person，此时<code>Person.prototype与__proto__</code>指向的是一个空间，把他返回给<code>var person。</code><br>先new再<code>Person.prototype={name:’cherry’}</code>已经晚了<br>在Person.prototype={name:’cherry’}时，Person.prototype空间改了，但是<code>__proto</code>指向的空间不变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">"sunny"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">new</span>的时候<span class="string">`var this = &#123;__proto__:Person.prototype&#125;`</span>里面的指向Person</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person</span><br><span class="line">Person.prototype=&#123;<span class="attr">name</span>:’cherry’&#125;</span><br><span class="line"><span class="comment">//原型改了，换了新的对象。改了个房间</span></span><br><span class="line"><span class="comment">//&#123;person.name = "sunny"&#125;</span></span><br><span class="line"><span class="comment">//但是`__proto`指向的空间不变。</span></span><br></pre></td></tr></table></figure>

<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ol>
<li>原型链上属性的增删改查<br>原型链上的增删改查和原型基本上是一致的。只有本人有的权限，子孙是没有的。</li>
<li>绝大多数对象的最终都会继承自Object.prototype </li>
<li>Object.create(原型); </li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Grand.prototype.__proto__ = <span class="built_in">Object</span>.prototype </span><br><span class="line"><span class="comment">// Object.prototype是原型链的终端</span></span><br></pre></td></tr></table></figure>

<p><code>son.fortune.card2=’master</code>’这种改，这是引用值自己的修改。属fortune.name给自己修改，这是一种调用方法的修改</p>
<p><code>son.num++是son.num=son.num+1</code>是先把父级的取过来再赋值+1，所以爹的没变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype&#123;</span><br><span class="line">	name： <span class="string">"a"</span>,</span><br><span class="line">	sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">"b"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person</span><br><span class="line"><span class="comment">//Person.sayName = b</span></span><br><span class="line"><span class="comment">//a.sayName ( )方法调用，就是say.Name里面的this指向，是谁调用的这个方法，this就指向谁</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; &#125;;也是有原型的</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>( );效果是一样的</span><br><span class="line">obj1.__proto__ → <span class="built_in">Object</span>.ptototype;</span><br><span class="line">但是在构造对象时，能用对象自变量<span class="keyword">var</span> obj = &#123; &#125;;</span><br><span class="line">就不要用<span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>( );</span><br><span class="line">对像自变量的原型就是<span class="built_in">Object</span>.ptototype;</span><br></pre></td></tr></table></figure>

<h3 id="Object-create-原型"><a href="#Object-create-原型" class="headerlink" title="Object.create(原型);"></a>Object.create(原型);</h3><p>Object.create也能创建对象。var obj = Object.create（这里必须要有原型）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line"><span class="comment">//var obj = Object.create(原型);</span></span><br></pre></td></tr></table></figure>

<p>绝大多数对象的最终都会继承自Object.prototype</p>
<p>原型是隐式的内部属性，你加是没有用的</p>
<p>undefined和null没有原型，也就不可能有toString方法</p>
<p>数字想用toString方法，要经过包装类包装new Number(num)然后. toString</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create()在括号里面只能放<span class="literal">null</span>或者<span class="built_in">Object</span>，其余会报错</span><br><span class="line">放<span class="literal">null</span>的时候可以不继承<span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure>

<p><code>new Number(num). toString的原型是Nunber.prototype</code></p>
<p><code>Nunber.prototype上面有一个.toString方法</code></p>
<p><code>Nunber.prototype也有原型Nunber.prototype.__proto__，原型是Object.prototype</code><br><code>假如new Number上面的prototype上面有这个toString，那么就不用Object.prototype的toString。而这个number上面有这个toString。</code></p>
<p>然后number上面的toString调用的是自己重写的toString。 原型上有这个方法，我自己又写了一个和原型上同一名字，但不同功能的方法，叫做重写（同一名字的函数，不同重写方式）</p>
<p>通过返回值，形参列表不同传参<br>同样的名实现不同功能的，就是重写</p>
<h2 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h2><p>作用，改变this指向。 </p>
<p>区别，后面传的参数形式不同。</p>
<p>任何一个方法都可以.call。call才是一个方法执行的真实面目</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">test.call();</span><br><span class="line"><span class="comment">//test（）和写test.call（）是一样的</span></span><br></pre></td></tr></table></figure>

<p>Person.call ( )和Person ( )没有区别<br>Person.call( );括号里面可以传东西 如果Person.call( obj );里面的call让person所有的this都变成obj<br>不new的话，this默认指向window。call的使用必须要new call的第一位参数用于改变this指向，第二位实参（对应第一个形参）及以后的参数都当做正常的实参，传到形参里面去 借用别人的方法，实现自己的功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,height</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,height, age</span>) </span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>, name, height)</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Student = <span class="keyword">new</span> Student(<span class="string">'Ting'</span>, <span class="string">'18'</span>, <span class="string">'180'</span>)</span><br><span class="line"><span class="comment">//Person.call(this, name, age, sex);里面的this现在是new了以后的var this=&#123;&#125;</span></span><br><span class="line"><span class="comment">//利用Person方法，实现了Student自己的封装</span></span><br></pre></td></tr></table></figure>

<p>call改变this指向，借用别人的函数，实现自己的功能。</p>
<p>只能在你的需求完全涵盖别人的时候才能使用</p>
<p>如果不想要name这个，就不能使用这种方法</p>
<p>apply也是改变this指向的，只是传参列表不同，第一位也是改变this指向的人，第二位，apply只能传一个实参，而且必须传数组argunments call需要把实参按照形参的个数传进去</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.apply(<span class="keyword">this</span>, [name, height])</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>传统形式 ==&gt; 原型链 //问题：过多的继承了没用的属性</li>
<li>借用构造函数 ==&gt;利用call、apply 所以不算标准的继承模式<ol>
<li>不能继承借用构造函数的原型 </li>
<li>每次构造函数都要多走一个函数 ==&gt;浪费效率</li>
</ol>
</li>
<li>共享原型（较好的继承方法） 不能随便改动自己的原型</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Son.prototype=Father.prototype</span><br><span class="line"><span class="comment">//extend和inherit都是继承的意思。</span></span><br><span class="line"><span class="comment">//inherit是css的一个值，也是继承的意思。</span></span><br><span class="line">文字类属性都有一个传递的特性：子元素没有设置文字类属性，子元素默认继承父元素的属性。</span><br><span class="line">font-size:inheit;我没有就继承父亲的</span><br><span class="line">在inherit（Target，Origin）里面传进去的值是构造函数，需要大驼峰式书写，origin是原始的意思，让target（目标）继承origin</span><br><span class="line"><span class="comment">//封装起来</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">    Target.prototype=Origin.prototype</span><br><span class="line">&#125;</span><br><span class="line">inherit(Son, Father);</span><br><span class="line">上面这种方式让son里面有了father原型的属性</span><br></pre></td></tr></table></figure>

<p>这种写法，son.prototype和father.prototype指向的是一个房间，改son就改了father。</p>
<p>我们希望son用的father的原型，但是改变son自己的属性不影响father。</p>
<ol start="4">
<li><p>圣杯模式</p>
<p>圣杯模式是在方法三的共有原型，但是在共有原型的基础上有改变。</p>
<p>共享原型是：son.prototype=father.prototype </p>
<p>圣杯模式是：另外加个构造函数function F（）{}当做中间层，然后让F和father共有一个原型F.prototype=father.prototype，然后son.prototype = new F（）；使用原型链形成了继承关系，现在改son.prototype就不会影响father.prototype</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">	F.prototype = Origin.prototype;</span><br><span class="line">    Target.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    Target.prototype.constuctor = Target;</span><br><span class="line">    Target.prototype.uber = Origin.prototype;</span><br><span class="line">&#125;</span><br><span class="line">inherit(Son, Father);</span><br><span class="line"></span><br><span class="line"><span class="comment">//雅虎的封装方式</span></span><br><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">        F.prototype = Origin.prototype;</span><br><span class="line">        Target.prototype = <span class="keyword">new</span> F();</span><br><span class="line">        Target.prototype.constuctor = Target;</span><br><span class="line">        Target.prototype.uber = Origin.prototype;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;())</span><br><span class="line"><span class="comment">//上面的var F这个F形成了闭包，成为了这个函数的私有化变量，而且变成私有化变量就更好</span></span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>（其实就是对象）管理变量，防止污染全局，适用于模块化开发</p>
<p>多人开发，对象命名容易重复，就要解决命名空间的问题</p>
<p>用闭包来解决（也可用webpack），返回方法的调用。init是初始化，入口函数，入口名字。init调用了这个函数的功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> init = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Ting"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      callName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>

<h3 id="实现链式调用"><a href="#实现链式调用" class="headerlink" title="实现链式调用"></a>实现链式调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deng = &#123;</span><br><span class="line">    smoke: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'吸烟'</span>)；</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>；</span><br><span class="line">    &#125;，</span><br><span class="line">    drink： <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        cosole.log(<span class="string">'喝酒'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">deng.smoke().drink().smoke()</span><br></pre></td></tr></table></figure>

<h3 id="属性的表示方法"><a href="#属性的表示方法" class="headerlink" title="属性的表示方法"></a>属性的表示方法</h3><p>obj[“prop”] 中括号也是访问属性的方法</p>
<p>用方括号来访问属性也是一样的（里面必须是字符串）<br>这两种基本上完全相同obj.name → obj [ ‘name’ ] </p>
<p>想实现属性名的拼接，只能用方括号的形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name &#123;</span><br><span class="line">    name1: &#123;<span class="attr">name</span>: <span class="string">"雄安"</span>&#125;，</span><br><span class="line">    name2: &#123;<span class="attr">name</span>: <span class="string">"珠海"</span>&#125;,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">        retuen <span class="keyword">this</span>[<span class="string">'wife'</span>+ num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的枚举"><a href="#对象的枚举" class="headerlink" title="对象的枚举"></a>对象的枚举</h3><p>for in循环(简化版for循环)，目的是便利对象，通过对象属性的个数来控制循环圈数，这个对象有多少属性循环多少圈，而且在每一圈时，都把对象的属性名放到Prop里面 在枚举里面，一定要写成obj[prop]不能加字符串 </p>
<p>1.hasOwnProperty 2.in 3.instanceof<br>枚举也就是遍历：挨个知道信息的过程就叫这个数据组的遍历</p>
<p>‘a’ in obj (需要字符)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不想把原型上面的属性拿出来，可以用hasOwnProperty，一般与for in循环成套出现</p>
<p>hasOwnProperty是一个方法，来判断这个对象是你自己的还是原型的， 把属性名传进去（如prop）。下面达到了如果不是自己的属性，是原型上的属性，就不会返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.hasOwnProperty(prop))&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(obj.[prop]);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>in操作符：很少用<br>in操作符你的也是你的，你父亲的也是你的，只能判断这个对象能不能访问到这个属性，包括原型上；不是判断属性属不属于这个对象的</p>
</li>
<li><p>instanceof操作用法类似于in</p>
<p>但是完全不同 A instanceof B的意思是A对象是不是B构造函数构造出来的；记住是：看A对象的原型链上有没有B的原型</p>
</li>
</ul>
<p>区别传的变量是数组还是对象的方法：一是constructor，二是instanceof</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> . prototype . toString . call ( [ ] ) ; <span class="comment">//[]会替换this</span></span><br><span class="line"><span class="built_in">Object</span> . prototype . toString = <span class="function"><span class="keyword">function</span> (<span class="params"> </span>) </span>&#123;</span><br><span class="line">识别<span class="keyword">this</span>（谁调的他，这个<span class="keyword">this</span>就是谁）</span><br><span class="line">返回相应的结果</span><br><span class="line">&#125;</span><br><span class="line">obj . toString ( ) ;</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ol>
<li><p>函数预编译过程 this —&gt;指向 window</p>
<p>前面的var this = Object.creat(test.prototype);是最标准的写法<br>new test（）；就会让var this = Object.creat(test.prototype);</p>
<p>如果不new，this指向window</p>
</li>
<li><p>全局作用域里 this —&gt; 指向window</p>
</li>
<li><p>call/apply 可以改变函数运行时this指向</p>
</li>
<li><p>obj.func(); func()里面的this指向obj</p>
<p>谁调用这个方法,这个方法里的this就是指向谁</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"222"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    naem : <span class="string">"111"</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = a.say;</span><br><span class="line">fun()<span class="comment">//222		222		222</span></span><br><span class="line">a.say()<span class="comment">//111	111		111</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">    name: <span class="string">"333"</span>;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</span><br><span class="line">        fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">b.say(a.say);<span class="comment">//333	222	333	111</span></span><br><span class="line">b.say = a.say;</span><br><span class="line">b.say();<span class="comment">//333	333	333</span></span><br><span class="line"></span><br><span class="line">a.say是<span class="function"><span class="keyword">function</span>函数体</span></span><br><span class="line"><span class="function"><span class="title">function</span> (<span class="params">fun</span>)</span>&#123;</span><br><span class="line"><span class="comment">//this → b</span></span><br><span class="line"><span class="comment">//console.log(this)→b</span></span><br><span class="line">fun( );</span><br><span class="line">&#125;</span><br><span class="line">fun()空执行，走预编译</span><br><span class="line">在b.say(a.say)中</span><br><span class="line">a.say当做参数传进来了</span><br></pre></td></tr></table></figure>

<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>在调用函数时，浏览器每次都会传递进两个隐含的参数：</p>
<p>1.函数的上下文对象 this</p>
<p>2.封装实参的对象 arguments</p>
<p>arguments是一个类数组对象,它也可以通过索引来操作数据，也可以获取长度</p>
<ul>
<li><p>在调用函数时，我们所传递的实参都会在arguments中保存</p>
</li>
<li><p>arguments.length可以用来获取实参的长度</p>
</li>
<li><p>我们即使不定义形参，也可以通过arguments来使用实参，</p>
</li>
</ul>
<p>只不过比较麻烦</p>
<p>arguments[0] 表示第一个实参</p>
<p>arguments[1] 表示第二个实参 。。。</p>
<ul>
<li><p>它里边有一个属性叫做callee，</p>
<p>这个属性对应一个函数对象，就是当前正在指向的函数的对象</p>
</li>
</ul>
<p>arguments.callee指向函数的引用（函数自己）</p>
<p>function.caller</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee == test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>我们要初始化数据，是100以内的阶乘，用立即执行函数<br>找到自己的引用来解决</p>
<p>在哪个函数里面的arguments.callee就指代了哪个函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        reyurn <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">arguments</span>.calleen(n - <span class="number">1</span>);</span><br><span class="line">&#125;(<span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><h3 id="浅层克隆"><a href="#浅层克隆" class="headerlink" title="浅层克隆"></a>浅层克隆</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	name: <span class="string">"Ting"</span></span><br><span class="line">&#125;</span><br><span class="line">vae obj1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin, target</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> targer = target || &#123;&#125;;</span><br><span class="line">	fro(<span class="keyword">var</span> prop <span class="keyword">in</span> origin) &#123;</span><br><span class="line">		target[prop] = prigin[prop];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line">clone(obj, obj1);</span><br></pre></td></tr></table></figure>

<h3 id="深度克隆的步骤"><a href="#深度克隆的步骤" class="headerlink" title="深度克隆的步骤"></a>深度克隆的步骤</h3><ol>
<li>先把所有的值都遍历一遍（看是引用值和原始值）用<code>for ( var prop in obj )</code>，对象和数组都可以使用</li>
<li>判断是原始值，还是引用值？用typeof判断是不是object<br>1）如果是原始值就直接拷贝<br>2）如果是引用值，判断是数组还是对象</li>
<li>判断是数组还是对象？（方法instanceof【看a的原型链上有没有b的原型】、toString、constructor，建议用toString,另外两个有个小bug——跨父子域不行）<br>1）如果是数组，就新建一个空数组；<br>2）如果是对象，就新建一个空对象。</li>
<li>建立了数组以后，如果是挨个看原始对象里面是什么，都是原始值就可以直接考过来了；或者，建立了对象以后，挨个判断对象里面的每一个值，看是原始值还是引用值</li>
<li>递归</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">origin, target</span>)</span>&#123;</span><br><span class="line">    vae target = target || &#123;&#125;,</span><br><span class="line">        toStr = <span class="built_in">Object</span>.prototype.toString,</span><br><span class="line">        arrStr = <span class="string">"[object Array]"</span>;</span><br><span class="line">    fro(<span class="keyword">var</span> prop <span class="keyword">in</span> origin) &#123;</span><br><span class="line">        <span class="keyword">if</span>(origin.hasOwnproperty(prop))&#123;</span><br><span class="line">            <span class="keyword">if</span>(origin[prop] !== <span class="string">"null"</span> &amp;&amp; <span class="keyword">typeof</span>(origin[prop]) == <span class="string">'object'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(toStr.call(origin[prop]) == aeeStr) &#123;</span><br><span class="line">                    target[prop] = [];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    target[prop] = &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                deepClone(origin[prop], target[prop]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                target[prop] = origin[prop];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>形式：?问号前面是一个条件判断，判断true就走：冒号前面的；false就走：冒号后面的，并且会返回值</p>
<p>条件判断？ 是 ： 否 并且会返回值<br>三目运算符是简化版的if（条件判断）{是在这里}else{否在这里}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar num = <span class="number">1</span> &gt; <span class="number">0</span> ? ( <span class="string">"10"</span> &gt; <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span> ) : <span class="number">2</span>;</span><br><span class="line"><span class="comment">//答1</span></span><br></pre></td></tr></table></figure>

<h2 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>数组的定义(来源于Array.prototype) </p>
<p>1）new Array(length/content); var arr = new Array(1,2,3,4,5 ); </p>
<p>2）字面量 var arr = [1,2,3,4,5]; </p>
</li>
<li><p>数组的读和写</p>
<p>arr [ num ] //不可以溢出读，结果undefined<br>arr[num] = XXX; //不可以溢出读<br>arr[num] = xxx; //可以溢出写</p>
</li>
</ul>
<p>数组是一种特殊的对象，在本质上两者没有太大的区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字面量来创建数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [,]; <span class="comment">//稀松数组，相当于定了两个位置，conlogo结果是undefined</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作文构造函数的参数传递</span></span><br><span class="line"><span class="comment">//元素之间使用,隔开</span></span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr3);<span class="comment">//10,20,30</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//创建一个数组数组中只有一个元素10</span></span><br><span class="line">arr = [<span class="number">10</span>];</span><br><span class="line">			</span><br><span class="line"><span class="comment">//创建一个长度为10的数组</span></span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>数组可以放任意的数据类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中的元素可以是任意的数据类型</span></span><br><span class="line">arr = [<span class="string">"hello"</span>,<span class="number">1</span>,<span class="literal">true</span>,<span class="literal">null</span>,<span class="literal">undefined</span>];</span><br><span class="line">			</span><br><span class="line"><span class="comment">//也可以是对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">"孙悟空"</span>&#125;;</span><br><span class="line">arr[arr.length] = obj;</span><br><span class="line">arr = [&#123;<span class="attr">name</span>:<span class="string">"孙悟空"</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">"沙和尚"</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">"猪八戒"</span>&#125;];</span><br><span class="line">			</span><br><span class="line"><span class="comment">//也可以是一个函数</span></span><br><span class="line">arr = [<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>)&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">2</span>)&#125;];</span><br><span class="line">			</span><br><span class="line"><span class="comment">//console.log(arr);</span></span><br><span class="line"><span class="comment">//arr[0]();</span></span><br><span class="line">			</span><br><span class="line"><span class="comment">//数组中也可以放数组，如下这种数组我们称为二维数组</span></span><br><span class="line">arr = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="数组常用的方法"><a href="#数组常用的方法" class="headerlink" title="数组常用的方法"></a>数组常用的方法</h3><ul>
<li><p>改变原数组（在原来数组基础上去改变） </p>
<p>1）reverse,sort,push,pop, unshift, shift</p>
<p>2）splice </p>
</li>
<li><p>不改变原数组 </p>
<p>1）forEach filter map reduce reduceRight </p>
<p>2）slice concat,join—&gt;split,toString</p>
</li>
</ul>
<ol>
<li><p>push是在数组的最后一位添加数据，可以添加一个，也可以添加很多个</p>
<p>数组有三位，想在数组最后一位添加东西</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];</span><br><span class="line"><span class="comment">//如果在第四位加东西写成arr = [3]。</span></span><br><span class="line"></span><br><span class="line">arr.push(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fro (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">this</span>[<span class="keyword">this</span>.length] = <span class="built_in">arguments</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Array . prototype.push = function ( )&#123; 不能写形参</span></span><br><span class="line"><span class="comment">//该方法会将数组新的长度作为返回值返回</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>pop是剪切方法（把最后一位数剪切出去）。</p>
<p>在pop( )括号里面不能传参，写了会忽略</p>
<p>终端：arr.pop()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"孙悟空"</span>,<span class="string">"猪八戒"</span>,<span class="string">"沙和尚"</span>];</span><br><span class="line">result = arr.pop();</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"result = "</span>+result);</span><br><span class="line"><span class="comment">//result = 沙和尚</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>unshift是从第一位加东西</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.unshift(<span class="string">"牛魔王"</span>,<span class="string">"二郎神"</span>);</span><br><span class="line"><span class="comment">//向数组开头添加一个或多个元素，并返回新的数组长度</span></span><br><span class="line"><span class="comment">//向前边插入元素以后，其他的元素索引会依次调整</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shift是从第一位开始减</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以删除数组的第一个元素，并将被删除的元素作为返回值返回</span></span><br><span class="line">result = arr.shift();</span><br><span class="line">result = arr.shift();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"result = "</span>+result);</span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse逆反</p>
</li>
<li><p>splice一种剪切，切片</p>
<p>arr.splice(从第几位开始，截取多少长度，传参在切口处添加新的数据)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="string">"孙悟空"</span>,<span class="string">"猪八戒"</span>,<span class="string">"沙和尚"</span>,<span class="string">"唐僧"</span>,<span class="string">"白骨精"</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.splice(<span class="number">3</span>,<span class="number">0</span>,<span class="string">"牛魔王"</span>,<span class="string">"铁扇公主"</span>,<span class="string">"红孩儿"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//"孙悟空","猪八戒","沙和尚","牛魔王","铁扇公主","红孩儿"，"唐僧","白骨精"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>sort给数组排序（按照从小到大），改变原数组</p>
<p>在sort后面加reverse就是降序</p>
<p>sort按asc码排序的 </p>
<p>​    1. 必须写两形参</p>
<p>​    2. 看返回值return </p>
<p>​        当返回值为负数时，那么前面的数放在前面</p>
<p>​        当返回值为正数时，那么后面的数在前</p>
<p>​        为0，不动</p>
<p>记住升序return a – b ; 降序 return b – a</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b-a;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，</span></span><br><span class="line"><span class="comment">* 	所以对数字进排序时，可能会得到错误的结果。</span></span><br><span class="line"><span class="comment">* 我们可以自己来指定排序的规则</span></span><br><span class="line"><span class="comment">* 	我们可以在sort()添加一个回调函数，来指定排序规则，</span></span><br><span class="line"><span class="comment">* 		回调函数中需要定义两个形参,</span></span><br><span class="line"><span class="comment">* 		浏览器将会分别使用数组中的元素作为实参去调用回调函数</span></span><br><span class="line"><span class="comment">* 		使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边</span></span><br><span class="line"><span class="comment">* 	- 浏览器会根据回调函数的返回值来决定元素的顺序，</span></span><br><span class="line"><span class="comment">* 		如果返回一个大于0的值，则元素会交换位置</span></span><br><span class="line"><span class="comment">* 		如果返回一个小于0的值，则元素位置不变</span></span><br><span class="line"><span class="comment">* 		如果返回一个0，则认为两个元素相等，也不交换位置 */</span></span><br></pre></td></tr></table></figure>

<h3 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h3><ol>
<li>concat连接， 把后面的数组拼到前面，并成立一个新的数组，不影响之前的两个数组。不能改变原数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.concat(arr1);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>toString 是把数组当做字符串展示出来</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.toStrion()</span><br><span class="line"><span class="comment">//"1, 2, 3"</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>slice( 从该位开始截取，截取到该位 )</p>
<p>并不改变原数组，这里也可以写负数</p>
<p>slice并不改变原数组slice完了以后需要有东西接收，不然没有意义</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.slice(<span class="number">-2</span>);<span class="comment">//倒数第2开始截取到最后</span></span><br><span class="line"><span class="comment">//[3, 4]</span></span><br><span class="line">arr.slice()<span class="comment">//整个截取</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>join括号里面需要用字符串形式（标准语法规定），就会用加的东西连接起数组</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.join(<span class="string">"~"</span>)</span><br><span class="line"><span class="comment">//1~2~3~4</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>join可逆的方法：split( )是string 字符串方法</p>
<p>split按照什么拆分为数组。用什么拆，什么就没了，按-拆就去掉-，按4拆就去掉4。<br>split可以返回数组，数组可以返回字符串</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.join(<span class="string">"~"</span>)</span><br><span class="line"><span class="comment">//1~2~3~4</span></span><br><span class="line">arr.split(<span class="string">"~"</span>)</span><br><span class="line"><span class="comment">//["1", "2", "3", "4"]</span></span><br></pre></td></tr></table></figure>

<h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"孙悟空"</span>,<span class="string">"猪八戒"</span>,<span class="string">"沙和尚"</span>,<span class="string">"唐僧"</span>,<span class="string">"白骨精"</span>];</span><br><span class="line"><span class="comment">//所谓的遍历数组，就是将数组中所有的元素都取出来</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;arr.length ; i++)&#123;</span><br><span class="line">				<span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//创建一个Person对象</span></span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">"孙悟空"</span>,<span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> per2 = <span class="keyword">new</span> Person(<span class="string">"猪八戒"</span>,<span class="number">28</span>);</span><br><span class="line"><span class="keyword">var</span> per3 = <span class="keyword">new</span> Person(<span class="string">"红孩儿"</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> per4 = <span class="keyword">new</span> Person(<span class="string">"蜘蛛精"</span>,<span class="number">16</span>);</span><br><span class="line"><span class="keyword">var</span> per5 = <span class="keyword">new</span> Person(<span class="string">"二郎神"</span>,<span class="number">38</span>);</span><br><span class="line"><span class="comment">//将这些person对象放入到一个数组中</span></span><br><span class="line"><span class="keyword">var</span> perArr = [per,per2,per3,per4,per5];</span><br><span class="line"><span class="comment">//创建一个函数，可以将perArr中的满18岁的Person提取出来，然后封装到一个新的数组中并返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAdult</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="comment">//创建一个新的数组</span></span><br><span class="line">	<span class="keyword">var</span> newArr = [];</span><br><span class="line"><span class="comment">//遍历arr，获取arr中Person对象</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;arr.length ; i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> p = arr[i];</span><br><span class="line"><span class="comment">//判断Person对象的age是否大于等于18</span></span><br><span class="line">		<span class="keyword">if</span>(p.age &gt;= <span class="number">18</span>)&#123;</span><br><span class="line"><span class="comment">//如果大于等于18，则将这个对象添加到newArr中</span></span><br><span class="line"><span class="comment">//将对象放入到新数组中</span></span><br><span class="line">			newArr.push(p);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">//将新的数组返回</span></span><br><span class="line">	<span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> result = getAdult(perArr);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p>forEach()遍历</p>
<p>这个方法只支持IE8以上的浏览器</p>
<p> IE8及以下的浏览器均不支持该方法，所以如果需要兼容IE8，则不要使用forEach</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"孙悟空"</span>,<span class="string">"猪八戒"</span>,<span class="string">"沙和尚"</span>,<span class="string">"唐僧"</span>,<span class="string">"白骨精"</span>];			</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* forEach()方法需要一个函数作为参数</span></span><br><span class="line"><span class="comment">* 	- 像这种函数，由我们创建但是不由我们调用的，我们称为回调函数</span></span><br><span class="line"><span class="comment">* 	- 数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素</span></span><br><span class="line"><span class="comment">* 		以实参的形式传递进来，我们可以来定义形参，来读取这些内容</span></span><br><span class="line"><span class="comment">* 	- 浏览器会在回调函数中传递三个参数：</span></span><br><span class="line"><span class="comment">* 		第一个参数，就是当前正在遍历的元素</span></span><br><span class="line"><span class="comment">* 		第二个参数，就是当前正在遍历的元素的索引</span></span><br><span class="line"><span class="comment">* 		第三个参数，就是正在遍历的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value , index , obj</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>];</span><br><span class="line">			</span><br><span class="line"><span class="comment">//去除数组中重复的数字</span></span><br><span class="line"><span class="comment">//获取数组中的每一个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;arr.length ; i++)&#123;</span><br><span class="line"><span class="comment">//console.log(arr[i]);</span></span><br><span class="line"><span class="comment">/*获取当前元素后的所有元素*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span> ; j&lt;arr.length ; j++)&#123;</span><br><span class="line"><span class="comment">//console.log("----&gt;"+arr[j]);</span></span><br><span class="line"><span class="comment">//判断两个元素的值是否相等</span></span><br><span class="line"><span class="keyword">if</span>(arr[i] == arr[j])&#123;</span><br><span class="line"><span class="comment">//如果相等则证明出现了重复的元素，则删除j对应的元素</span></span><br><span class="line">arr.splice(j,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//当删除了当前j所在的元素以后，后边的元素会自动补位</span></span><br><span class="line"><span class="comment">//此时将不会在比较这个元素吧，我需要在比较一次j所在位置的元素</span></span><br><span class="line"><span class="comment">//使j自减</span></span><br><span class="line">		j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h2><p>类数据特点：</p>
<ol>
<li>可以利用属性名模拟数组的特性</li>
<li>可以动态的增长length属性</li>
<li>如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充。</li>
</ol>
<p>看着像数组，但是数组有的方法，他全部都没有，所以他是类数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vae obj = &#123;</span><br><span class="line">    <span class="string">"0"</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">"1"</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">"2"</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">"length"</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台push(‘d’)以后，obj的object多了一个3：d，长度也变成了4 类数组：属性要为索引（数字）属性，必须要有length属性，最好加上push方法。 </p>
<p>例：如果给一个对象加上splice方法，那么这个对象就长得像数组了。但他仍然是对象，但是可以当做数组来用，需要自己添方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.pototype.puth = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    obj[obj.lenth] = target;</span><br><span class="line">    obj.length ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目一：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vae obj = &#123;</span><br><span class="line">    <span class="string">"2"</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">"3"</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">"length"</span>: <span class="number">2</span>，</span><br><span class="line">    <span class="string">"push"</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br><span class="line">obj.puth(<span class="string">'c'</span>);</span><br><span class="line">obj.puth(<span class="string">'d'</span>);</span><br><span class="line"><span class="comment">//原理如下</span></span><br><span class="line"><span class="built_in">Array</span>.pototype.puth = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    obj[obj.lenth] = target;</span><br><span class="line">    obj.length ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//答案</span></span><br><span class="line">vae obj = &#123;</span><br><span class="line">    <span class="string">"2"</span>: <span class="string">'c'</span>,</span><br><span class="line">    <span class="string">"3"</span>: <span class="string">'d'</span>,</span><br><span class="line">    <span class="string">"length"</span>: <span class="number">4</span>，</span><br><span class="line">    <span class="string">"push"</span>: <span class="built_in">Array</span>.prototype.push</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><p>日期对象 Date()——就是一种对象，是系统提供好的 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Date对象</span></span><br><span class="line"><span class="comment">//如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间</span></span><br><span class="line">	<span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">			</span><br><span class="line"><span class="comment">//创建一个指定的时间对象</span></span><br><span class="line"><span class="comment">//需要在构造函数中传递一个表示时间的字符串作为参数</span></span><br><span class="line"><span class="comment">//日期的格式  月份/日/年 时:分:秒</span></span><br><span class="line">	<span class="keyword">var</span> d2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2/18/2011 11:10:30"</span>);</span><br><span class="line"><span class="comment">//getDate()获取当前日期对象是几日</span></span><br><span class="line">	<span class="keyword">var</span> date = d2.getDate();</span><br></pre></td></tr></table></figure>

<p>var date = new Date()大写的Date是系统提供的一个构造函数，通过new Date的方法会给我们返回一个对象，这个对象就是一个日期对象。日期对象有很多属性和方法。小的date代表此时此刻的时间。用小的date调用方法，如date.getDate( ) Date 对象属性(不够标准)</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">constructor</td>
<td align="center">返回对创建此对象的 Date 函数的引用。原型上的属性。</td>
</tr>
<tr>
<td align="center">prototype</td>
<td align="center">使您有能力向对象添加属性和方法。prototype是构造函数的属性</td>
</tr>
</tbody></table>
<p>Date 对象方法</p>
<p>getTime()</p>
<ul>
<li>获取当前日期对象的时间戳</li>
<li>时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒<br>到当前日期所花费的毫秒数（1秒 = 1000毫秒）</li>
<li>计算机底层在保存时间时使用都是时间戳</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = d2.getTime();</span><br><span class="line"><span class="comment">//console.log(time/1000/60/60/24/365);</span></span><br><span class="line"><span class="comment">/*var d3 = new Date("1/1/1970 0:0:0");</span></span><br><span class="line"><span class="comment">time = d3.getTime();</span></span><br><span class="line"><span class="comment">console.log(time);*/</span></span><br><span class="line"><span class="comment">//利用时间戳来测试代码的执行的性能</span></span><br><span class="line"><span class="comment">//获取当前的时间戳</span></span><br><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">			</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">100</span> ; i++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">var</span> end = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"执行了："</span>+(end - start)+<span class="string">"毫秒"</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_Date.asp" target="_blank" rel="noopener">Date()</a></td>
<td align="center">返回当日的日期和时间。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getDate.asp" target="_blank" rel="noopener">getDate()</a></td>
<td align="center">从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getDay.asp" target="_blank" rel="noopener">getDay()</a></td>
<td align="center">从 Date 对象返回一周中的某一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getMonth.asp" target="_blank" rel="noopener">getMonth()</a></td>
<td align="center">从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getFullYear.asp" target="_blank" rel="noopener">getFullYear()</a></td>
<td align="center">从 Date 对象以四位数字返回年份。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getYear.asp" target="_blank" rel="noopener">getYear()</a></td>
<td align="center">请使用 getFullYear() 方法代替。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getHours.asp" target="_blank" rel="noopener">getHours()</a></td>
<td align="center">返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getMinutes.asp" target="_blank" rel="noopener">getMinutes()</a></td>
<td align="center">返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getSeconds.asp" target="_blank" rel="noopener">getSeconds()</a></td>
<td align="center">返回 Date 对象的秒数 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getMilliseconds.asp" target="_blank" rel="noopener">getMilliseconds()</a></td>
<td align="center">返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getTime.asp" target="_blank" rel="noopener">getTime()</a></td>
<td align="center">返回 1970 年 1 月 1 日至今的毫秒数。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getTimezoneOffset.asp" target="_blank" rel="noopener">getTimezoneOffset()</a></td>
<td align="center">返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCDate.asp" target="_blank" rel="noopener">getUTCDate()</a></td>
<td align="center">根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCDay.asp" target="_blank" rel="noopener">getUTCDay()</a></td>
<td align="center">根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCMonth.asp" target="_blank" rel="noopener">getUTCMonth()</a></td>
<td align="center">根据世界时从 Date 对象返回月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCFullYear.asp" target="_blank" rel="noopener">getUTCFullYear()</a></td>
<td align="center">根据世界时从 Date 对象返回四位数的年份。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCHours.asp" target="_blank" rel="noopener">getUTCHours()</a></td>
<td align="center">根据世界时返回 Date 对象的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCMinutes.asp" target="_blank" rel="noopener">getUTCMinutes()</a></td>
<td align="center">根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCSeconds.asp" target="_blank" rel="noopener">getUTCSeconds()</a></td>
<td align="center">根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_getUTCMilliseconds.asp" target="_blank" rel="noopener">getUTCMilliseconds()</a></td>
<td align="center">根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_parse.asp" target="_blank" rel="noopener">parse()</a></td>
<td align="center">返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setDate.asp" target="_blank" rel="noopener">setDate()</a></td>
<td align="center">设置 Date 对象中月的某一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setMonth.asp" target="_blank" rel="noopener">setMonth()</a></td>
<td align="center">设置 Date 对象中月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setFullYear.asp" target="_blank" rel="noopener">setFullYear()</a></td>
<td align="center">设置 Date 对象中的年份（四位数字）。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setYear.asp" target="_blank" rel="noopener">setYear()</a></td>
<td align="center">请使用 setFullYear() 方法代替。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setHours.asp" target="_blank" rel="noopener">setHours()</a></td>
<td align="center">设置 Date 对象中的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setMinutes.asp" target="_blank" rel="noopener">setMinutes()</a></td>
<td align="center">设置 Date 对象中的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setSeconds.asp" target="_blank" rel="noopener">setSeconds()</a></td>
<td align="center">设置 Date 对象中的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setMilliseconds.asp" target="_blank" rel="noopener">setMilliseconds()</a></td>
<td align="center">设置 Date 对象中的毫秒 (0 ~ 999)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setTime.asp" target="_blank" rel="noopener">setTime()</a></td>
<td align="center">以毫秒设置 Date 对象。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCDate.asp" target="_blank" rel="noopener">setUTCDate()</a></td>
<td align="center">根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCMonth.asp" target="_blank" rel="noopener">setUTCMonth()</a></td>
<td align="center">根据世界时设置 Date 对象中的月份 (0 ~ 11)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCFullYear.asp" target="_blank" rel="noopener">setUTCFullYear()</a></td>
<td align="center">根据世界时设置 Date 对象中的年份（四位数字）。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setutchours.asp" target="_blank" rel="noopener">setUTCHours()</a></td>
<td align="center">根据世界时设置 Date 对象中的小时 (0 ~ 23)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCMinutes.asp" target="_blank" rel="noopener">setUTCMinutes()</a></td>
<td align="center">根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCSeconds.asp" target="_blank" rel="noopener">setUTCSeconds()</a></td>
<td align="center">根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_setUTCMilliseconds.asp" target="_blank" rel="noopener">setUTCMilliseconds()</a></td>
<td align="center">根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_tosource_boolean.asp" target="_blank" rel="noopener">toSource()</a></td>
<td align="center">返回该对象的源代码。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_toString_date.asp" target="_blank" rel="noopener">toString()</a></td>
<td align="center">把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_toTimeString.asp" target="_blank" rel="noopener">toTimeString()</a></td>
<td align="center">把 Date 对象的时间部分转换为字符串。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_toDateString.asp" target="_blank" rel="noopener">toDateString()</a></td>
<td align="center">把 Date 对象的日期部分转换为字符串。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_toGMTString.asp" target="_blank" rel="noopener">toGMTString()</a></td>
<td align="center">请使用 toUTCString() 方法代替。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_toUTCString.asp" target="_blank" rel="noopener">toUTCString()</a></td>
<td align="center">根据世界时，把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_toLocaleString.asp" target="_blank" rel="noopener">toLocaleString()</a></td>
<td align="center">根据本地时间格式，把 Date 对象转换为字符串。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_toLocaleTimeString.asp" target="_blank" rel="noopener">toLocaleTimeString()</a></td>
<td align="center">根据本地时间格式，把 Date 对象的时间部分转换为字符串。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_toLocaleDateString.asp" target="_blank" rel="noopener">toLocaleDateString()</a></td>
<td align="center">根据本地时间格式，把 Date 对象的日期部分转换为字符串。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_utc.asp" target="_blank" rel="noopener">UTC()</a></td>
<td align="center">根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_valueOf_date.asp" target="_blank" rel="noopener">valueOf()</a></td>
<td align="center">返回 Date 对象的原始值。</td>
</tr>
</tbody></table>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>setInterval(); //注意：setInterval(“func()”,1000);定时循环器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例setInerval(function () &#123;&#125;,1000);定时器，意思是1000毫秒执行一次这个函数</span></span><br><span class="line"><span class="keyword">var</span> time = <span class="number">1000</span>;</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;time);</span><br></pre></td></tr></table></figure>

<p>setInterval计算时间非常不准</p>
<p>注意：setInterval();是window的方法，在全局上就算不写window. setInterval();他也会上全局的GO 里面查找，所以不写window.也行。 每一个setInterval();都会返回一个一个数字，作为唯一的标识，有唯一标识就可以把他清除掉（利用clearInerval清除）</p>
<p>clearInterval(); //能让setInterval停止</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般写了setInterval就要写clearInterval</span></span><br><span class="line"><span class="keyword">var</span> time = <span class="number">1000</span>;</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">10</span>)&#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;time);</span><br></pre></td></tr></table></figure>

<p>setTimeout(); //正真的定时器,隔了一段时间后再执行（起推迟作用），并且只执行一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例隔了1000毫秒才执行，并且只执行一次</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>clearTimeout(); //清除setTimeout();让他停止执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种写法，setTimeout();还没执行就被清除了，就执行不了</span></span><br><span class="line"><span class="keyword">var</span> timrr = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;<span class="number">1000</span>);</span><br><span class="line">clearTimeout(timer);</span><br></pre></td></tr></table></figure>

<p>setInterval();setTimeout();clearInterval();clearTimeout();这四个都是全局对象，都是window上的方法，内部函数this指向window</p>
<h2 id="try…catch防止我们报错"><a href="#try…catch防止我们报错" class="headerlink" title="try…catch防止我们报错"></a>try…catch防止我们报错</h2><p>try花括号{里面会正常执行，但是遇到b报错时b就执行不出来，后面的代码c就不执行了，但是外面的代码d还能执行}catch(e)，这个e可以随便写，写abc都可以，也是个形参</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'e'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果try里面的代码不出错，在catch里面的代码就不执行； 如果try里面的代码出错，catch负责补抓到错误信息封装到里面（error.massage error.name），错误对象只有message和name。</p>
<h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p>Error.name的六种值对应的信息：<br>（前面是错误名称，后面是错误信息）</p>
<ol>
<li>EvalError：eval()的使用与定义不一致<br>//eval是不被允许使用的</li>
<li>RangeError：数值越界</li>
<li>ReferenceError：非法或不能识别的引用数值<br>//未经声明就使用，没有定义就使用</li>
<li>SyntaxError：发生语法解析错误<br>// Syntax是语法解析（）</li>
<li>TypeError：操作数类型错误</li>
<li>URIError：URI处理函数使用不当<br>//引用地址错误<br>大部分都是3和4这种错误</li>
</ol>
<h2 id="es5-0严格模式"><a href="#es5-0严格模式" class="headerlink" title="es5.0严格模式"></a>es5.0严格模式</h2><p>es5.0严格模式是指es3.0和es5.0产生冲突发部分就是用es5.0，否则就用es3.0。 es5.0严格模式的启动“use strict” ; 用法在整个页面的最顶端写“use strict”，可以写在全局的最顶端，也可以写在某函数（局部）的最顶端，推荐使用局部的。</p>
<p><code>“use strict” ;</code> </p>
<p>不再兼容es3的一些不规则语法。使用全新的es5规范。两种用法：</p>
<ol>
<li><p>全局严格模式 </p>
</li>
<li><p>局部函数内严格模式（推荐）<br>就是一行字符串，不会对不兼容严格模式的浏览器产生影响。<br>不支持with，arguments.callee，function.caller，变量赋值前必须声明，局部this必须被赋值(Person.call(null/undefined) 赋值什么就是什么),拒绝重复属性和参数</p>
</li>
<li><p>浏览器升级到es5.0才好用<br>写strict( );就有风险<br>写成“use strict” ;有一个向后兼容的作用 </p>
</li>
<li><p>例es5.0严格模式不让使用with。<br>with可以改变作用域链 with（）括号里面的代码会按照正常顺序执行，但是如果在括号里面添加了对象，就会把对象当做with要执行的代码体的作用域链的最顶端（最直接的最近的AO）。</p>
</li>
<li><p>es5.0不能用argument.callee，但是es3.0可以用</p>
</li>
<li><p>arguments.callee在es5.0严格模式下报错</p>
</li>
<li><p>es5.0严格模式中：变量赋值前必须声明，局部this必须被赋值(Person.call(null/undefined) 赋值什么就是什么),拒绝重复属性和参数（this不在指向window）</p>
</li>
<li><p>eval很强大，能把字符串当成代码来执行<br>但是约定俗成在es3.0中都不能使用eval。eval是魔鬼，因为会改变作用域</p>
</li>
<li><p>如果改变global，他改变的是全局的<br>当情况不同，eval改变的作用域是不同的<br>eval还有自己独立的作用域 理解：可以把回调函数理解为先定义好了函数，执行的时候再回头调用</p>
</li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式的作用：匹配特殊字符或有特殊搭配原则的字符的最佳选择。<br>RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具（判断字符串满不满足要求）。正则表达式其他语言也有，规则是一样的，在这个基础上，js增加了自己独特的方法。</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="正则表达式字面量（推荐）"><a href="#正则表达式字面量（推荐）" class="headerlink" title="正则表达式字面量（推荐）"></a>正则表达式字面量（推荐）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法：var 变量 = /正则表达式/匹配模式</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/abc/igm</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"acbd"</span>;</span><br><span class="line">reg.test(str)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数new-RegExp"><a href="#构造函数new-RegExp" class="headerlink" title="构造函数new RegExp();"></a>构造函数new RegExp();</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="comment">//语法：var 变量 = new RegExp("正则表达式","匹配模式");</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"abc"</span>, <span class="string">"igm"</span>);</span><br><span class="line"><span class="comment">//i 忽略大小写  g 全局匹配模式	m执行多行匹配</span></span><br><span class="line"><span class="keyword">var</span> result = reg.test(str);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h5 id="RegExp-对象属性"><a href="#RegExp-对象属性" class="headerlink" title="RegExp 对象属性"></a>RegExp 对象属性</h5><table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">global</td>
<td align="center">RegExp 对象是否具有标志 g。</td>
</tr>
<tr>
<td align="center">ignoreCase</td>
<td align="center">RegExp 对象是否具有标志 i。</td>
</tr>
<tr>
<td align="center">lastIndex 最有用</td>
<td align="center">一个整数，标示开始下一次匹配的字符位置。</td>
</tr>
<tr>
<td align="center">multiline</td>
<td align="center">RegExp 对象是否具有标志 m。</td>
</tr>
<tr>
<td align="center">source</td>
<td align="center">正则表达式的源文本。</td>
</tr>
</tbody></table>
<h5 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h5><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>编译正则表达式。</td>
</tr>
<tr>
<td>exec 厉害的方法</td>
<td>检索字符串中指定的值。返回找到的值，并确定其位置。</td>
</tr>
<tr>
<td>test</td>
<td>检索字符串中指定的值。返回 true 或 false。</td>
</tr>
</tbody></table>
<p>reg.exec( );是一个匹配的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/ab/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"ababababab"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex);</span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str));</span><br></pre></td></tr></table></figure>

<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td align="center">忽略大小写。</td>
</tr>
<tr>
<td align="center">g</td>
<td align="center">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">执行多行匹配。</td>
</tr>
</tbody></table>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[abc]</td>
<td align="center">查找方括号之间的任何字符。</td>
</tr>
<tr>
<td align="center">[0-9]</td>
<td align="center">查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td align="center">(x|y)</td>
<td align="center">查找由 | 分隔的任何选项。</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[]里的内容也是或的关系</span><br><span class="line">[ab] == a|b</span><br><span class="line">[a-z] 任意小写字母</span><br><span class="line">[A-Z] 任意大写字母</span><br><span class="line">[A-z] 任意字母</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>] 任意数字</span><br><span class="line">reg = <span class="regexp">/[A-z]/</span>;</span><br><span class="line"><span class="comment">//检查一个字符串中是否含有 abc 或 adc 或 aec</span></span><br><span class="line">reg = <span class="regexp">/abc|adc|aec/</span>;</span><br><span class="line">reg = <span class="regexp">/a[bde]c/</span>;</span><br></pre></td></tr></table></figure>

<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><table>
<thead>
<tr>
<th align="center">元字符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\d</td>
<td align="center">查找数字。</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">查找空白字符。</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">匹配单词边界。</td>
</tr>
<tr>
<td align="center">\uxxxx</td>
<td align="center">查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
</tbody></table>
<p>正则表达式的元字符和表达式是一个东西</p>
<p>元字符（Metacharacter）是拥有特殊含义的字符： </p>
<ul>
<li><p>\w代表一位，w意思是world， \w===完全等于[0-9A-z_] \W === [^\w] 大写\W是非的\w</p>
</li>
<li><p>\d === [0-9] \D ==== [^\d] ， \D ==== [^0-9]</p>
</li>
<li><p>\s === [空白字符，即\t\n\r\v\f ] 最常用的是空格和换行<br>在正则表达式中写空格就代表空格 \S ==== [非空白字符]</p>
</li>
<li><p>\b === 单词边界 \B ==== 非单词边界<br>单词边界在字符串里面可以看成 （空格）</p>
</li>
<li><p>注意：代表一切的集合var reg = /[/s/S]/;或者/[/d/D]/这样类似的</p>
<p>空白字符可以是： 最常用的是空格和换行<br>制表符(tab character)                         \t<br>回车符(carriage return character)       \r<br>换行符 (new line character)                \n<br>垂直换行符 (vertical tab character)     \v<br>换页符 (form feed character)               \f</p>
</li>
</ul>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><ul>
<li><p>n+ 匹配任何包含至少一个 n 的字符串。这个变量可以出现1到无数次。</p>
</li>
<li><p>n* 匹配任何包含零个或多个 n 的字符串。这个变量可以出现0到无数次。</p>
<p>n是一个变量，n+代表这个变量可以重复出现1次到无数次，n*代表{0到正无穷}</p>
<p>正则表达式有一个贪婪匹配原则，能多就不少</p>
</li>
<li><p>n? 匹配任何包含零个或一个 n 的字符串。这个变量0或1个一匹配。</p>
</li>
<li><p>n{X} 匹配包含 X 个 n 的序列的字符串。</p>
</li>
<li><p>n{X,Y} 匹配包含 X 至 Y 个 n 的序列的字符串。</p>
</li>
<li><p>n{X, } 匹配包含至少 X 个 n 的序列的字符串。</p>
</li>
<li><p>n$ 匹配任何结尾为 n 的字符串。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/a&#123;3&#125;/</span>;</span><br><span class="line"><span class="comment">//ababab</span></span><br><span class="line">reg = <span class="regexp">/(ab)&#123;3&#125;/</span>;</span><br><span class="line">reg = <span class="regexp">/b&#123;3&#125;/</span>;</span><br><span class="line">reg = <span class="regexp">/ab&#123;1,3&#125;c/</span>;</span><br><span class="line">reg = <span class="regexp">/ab&#123;3,&#125;c/</span>;</span><br><span class="line">reg = <span class="regexp">/ab+c/</span>;</span><br><span class="line">reg = <span class="regexp">/ab*c/</span>;</span><br><span class="line">reg = <span class="regexp">/ab?c/</span>;</span><br><span class="line"><span class="comment">//console.log(reg.test("abbc"));</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 检查一个字符串中是否以a开头</span></span><br><span class="line"><span class="comment">* 	^ 表示开头</span></span><br><span class="line"><span class="comment">* 	$ 表示结尾</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reg = <span class="regexp">/^a/</span>; <span class="comment">//匹配开头的a</span></span><br><span class="line">reg = <span class="regexp">/a$/</span>; <span class="comment">//匹配结尾的a</span></span><br><span class="line"><span class="comment">//console.log(reg.test("abcabca"));</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reg = <span class="regexp">/^a$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">"bbca"</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 创建一个正则表达式，用来检查一个字符串是否是一个合法手机号</span></span><br><span class="line"><span class="comment">* 手机号的规则：</span></span><br><span class="line"><span class="comment">* 	1 3 567890123 （11位）	</span></span><br><span class="line"><span class="comment">* 	1. 以1开头</span></span><br><span class="line"><span class="comment">*  2. 第二位3-9任意数字</span></span><br><span class="line"><span class="comment">* 	3. 三位以后任意数字9个</span></span><br><span class="line"><span class="comment">*  ^1   [3-9]  [0-9]&#123;9&#125;$  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> phoneStr = <span class="string">"13067890123"</span>;</span><br><span class="line"><span class="keyword">var</span> phoneReg = <span class="regexp">/^1[3-9][0-9]&#123;9&#125;$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(phoneReg.test(phoneStr));</span><br></pre></td></tr></table></figure>



<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>reg.test( ); 只能判断这个字符串有没有符合要求的片段，返回结果只有true和false </p>
<p>str.match( ); 可以把所有东西都匹配出来，返回给你，比上一种方法更直观，还能告诉你返回了多少个</p>
<p>^a的意思是必须是这个a开头，那么下面这串就只有一个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^a/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"abcdea"</span>;</span><br><span class="line">str.match(reg)</span><br><span class="line"><span class="comment">//["a"]</span></span><br></pre></td></tr></table></figure>

<p>^在表达式里面和外面的意思是不一样的，在里面是非的意思</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rag = <span class="regexp">/[^a][^b]/</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"abcde\na"</span>;</span><br><span class="line">str.match(rag);</span><br><span class="line"><span class="comment">//["b1"],["cd"]</span></span><br></pre></td></tr></table></figure>

<p>正则表达式中 | 是或的意思，下面是匹配abc或bcd</p>
<h4 id="string方法"><a href="#string方法" class="headerlink" title="string方法"></a>string方法</h4><ul>
<li>match 找到一个或多个正则表达式的匹配。</li>
<li>search 检索与正则表达式相匹配的值。<br>返回的不是-1都匹配成功了，返回的是匹配的这个东西的位置。</li>
<li>split 把字符串分割为字符串数组。</li>
<li>replace 替换与正则表达式匹配的子串。 非常实用</li>
</ul>
<p>支持正则表达式的 String 对象的方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_search.asp" target="_blank" rel="noopener">search</a></td>
<td align="center">检索与正则表达式相匹配的值。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_match.asp" target="_blank" rel="noopener">match</a></td>
<td align="center">找到一个或多个正则表达式的匹配。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_replace.asp" target="_blank" rel="noopener">replace</a></td>
<td align="center">替换与正则表达式匹配的子串。</td>
</tr>
<tr>
<td align="center"><a href="https://www.w3school.com.cn/jsref/jsref_split.asp" target="_blank" rel="noopener">split</a></td>
<td align="center">把字符串分割为字符串数组。</td>
</tr>
</tbody></table>
<p><code>search()</code></p>
<p>可以搜索字符串中是否含有指定内容</p>
<p>如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回-1</p>
<p>它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串</p>
<p><code>serach()</code>只会查找第一个，即使设置全局匹配也没用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"hello abc hello aec afc"</span>;</span><br><span class="line"><span class="comment">//搜索字符串中是否含有abc 或 aec 或 afc</span></span><br><span class="line">result = str.search(<span class="regexp">/a[bef]c/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p><code>match()</code></p>
<p>可以根据正则表达式，从一个字符串中将符合条件的内容提取出来</p>
<p>默认情况下我们的match只会找到第一个符合要求的内容，找到以后就停止检索</p>
<p>我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容</p>
<p>可以为一个正则表达式设置多个匹配模式，且顺序无所谓</p>
<p><code>match()</code>会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"1a2a3a4a5e6f7A8B9C"</span>;</span><br><span class="line">result = str.match(<span class="regexp">/[a-z]/ig</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//匹配到了会返回数组result接受</span></span><br></pre></td></tr></table></figure>

<p><code>replace（）</code>的精华是正则表达式</p>
<p>可以将字符串中指定内容替换为新的内容</p>
<p>参数：</p>
<p> 1.被替换的内容，可以接受一个正则表达式作为参数</p>
<p> 2.新的内容</p>
<p>默认只会替换第一个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = str.replace(<span class="regexp">/[a-z]/gi</span> , <span class="string">"@_@"</span>);</span><br><span class="line">result = str.replace(<span class="regexp">/[a-z]/gi</span> , <span class="string">""</span>);<span class="comment">//删除</span></span><br><span class="line"><span class="comment">//console.log(result);</span></span><br></pre></td></tr></table></figure>

<p><code>str.replace(reg,””)</code>替换的信息不管写什么都要写成字符串，字符串里面“$1”代表第一个子表达式的内容，“$2”代表第二个子表达式的内容</p>
<p>写成function，而function（， ，）{}里面传的第一个参数是正则表达式匹配的全局（结果）（可随便起名），第二个参数是第一个表达式匹配的内容，第三个参数是第二个表达式匹配的内容（写return$1$2不适合语法）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例把the-first-name变成小驼峰式写法theFirstName</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/-(\w)/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"the-first-name"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params">$, $<span class="number">1</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $<span class="number">1.</span>toUpperCase();</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>split()</p>
<p>可以将一个字符串拆分为一个数组</p>
<p>方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串</p>
<p>这个方法即使不指定全局匹配，也会全都插分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据任意字母来将字符串拆分</span></span><br><span class="line"><span class="keyword">var</span> result = str.split(<span class="regexp">/[A-z]/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);	</span><br><span class="line"><span class="comment">//输出数组</span></span><br></pre></td></tr></table></figure>



<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>正向预查/正向断言</p>
<ul>
<li><p>?=n 匹配任何其后紧接指定字符串 n 的字符串。<br>例我要选一个a，后面跟着b，就是正向预查/正向断言<br>/a(?=b)/意思是a后面跟着b，但是b不参与选择 </p>
</li>
<li><p>?!n 匹配任何其后没有紧接指定字符串 n 的字符串。后面不跟着n</p>
</li>
</ul>
<p>贪婪匹配，变成非贪婪匹配（能少就不多），在量词后面加个?</p>
<p>例var reg = /a{1,3}?/g; //这个1到3，意思是有1就不取2，3</p>
<p>思考：如果在量词是?? 例var reg = /a??/g;     //??第一个问号代表量词，第二个问号叫取消他的匹配，第一个</p>
<p>问号是0-1的意思，加个问号就是能取0就不取</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ol>
<li>DOM — &gt; Document Object Model(文档对象模型) </li>
<li>DOM定义了表示和修改文档所需的方法（对象、这些对象的行为和属性以及这些对象之间的关系。）DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml功能的一类对象的集合。 也有人称DOM是对HTML以及XML的标准编程接口。<br>xml ==&gt; xhtml ==&gt; html<br>xml是最早的版本，xml里面的标签是可以自定义的，被js里面的Jason取代了<br>dom不能改变css样式表,可以间接改变行间样式的css</li>
</ol>
<p>说的改变不了css是指改变不了css的样式表，但是可以通过间接方式改变html的行间样式来改变</p>
<p>DOM — &gt; Document Object Model(文档对象模型) </p>
<ol>
<li>文档：表示整个HTML网页文档</li>
<li>对象：网页没有办法都转化为一个对象</li>
<li>模型：表示对象之间的关系，获取对象</li>
</ol>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>节点：Node一一构成文档的最基本单元</p>
<h4 id="常用节点分类"><a href="#常用节点分类" class="headerlink" title="常用节点分类"></a>常用节点分类</h4><ol>
<li>文档节点（document）：整个HTML文档</li>
<li>元素节点（Element）：HTNL文档的HTML标签</li>
<li>属性节点（Attr）：元素的属性</li>
<li>文本节点（text）：HTML标签的文本内容</li>
</ol>
<h4 id="节点的类型"><a href="#节点的类型" class="headerlink" title="节点的类型"></a>节点的类型</h4><p>后面的数字是调用nodeType返回的数字<br>元素节点 —— 1<br>属性节点 —— 2 （基本没用，）<br>文本节点 —— 3<br>注释节点 —— 8<br>document —— 9<br>DocumentFragment —— 11</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- This is comment --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">七个节点，第一个节点是<span class="tag">&lt;<span class="name">div</span>&gt;</span>后面的文本节点（空格回车），第二个节点是注释节点，第三个节点是跟着的文本节点（空格回车），第四个节点是元素节点<span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span>，第五个是跟着的文本节点（空格回车），第六个是<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>，第七个是跟着的文本节点（空格回车）</span><br></pre></td></tr></table></figure>

<p>基于元素节点树的遍历（不含文本节点）<br>（除children外，其余ie9及以下不兼容）</p>
<ol>
<li>parentElement -&gt; 返回当前元素的父元素节点 (IE不兼容)</li>
<li>children -&gt; 只返回当前元素的元素子节点</li>
<li>node.childElementCount === node.children.length当前元素节点的子元素节点个数(IE 不兼容)——基本不用，因为与length相等</li>
<li>firstElementChild -&gt; 返回的是第一个元素节点(IE不兼容) </li>
<li>lastElementChild -&gt; 返回的是最后一个元素节点(IE不兼容)</li>
<li>nextElementSibling / previousElementSibling -&gt;返回后一个/前一个兄弟元素节点（IE不兼容)</li>
</ol>
<p>除children外，parentElement、node.childElementCount、firstElementChild、lastElementChild、nextElementSibling、 previousElementSibling在 ie9及以下不兼容<br>真正常用的就是children，兼容性好</p>
<h4 id="节点的四个属性"><a href="#节点的四个属性" class="headerlink" title="节点的四个属性"></a>节点的四个属性</h4><p>节点的属性（了解）</p>
<table>
<thead>
<tr>
<th></th>
<th>nodeName</th>
<th>nodeType</th>
<th>nodeValue</th>
</tr>
</thead>
<tbody><tr>
<td>文档节点</td>
<td>#document</td>
<td>9</td>
<td>null</td>
</tr>
<tr>
<td>元素节点</td>
<td>标签名</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>属性节点</td>
<td>属性名</td>
<td>2</td>
<td>属性值</td>
</tr>
<tr>
<td>文本节点</td>
<td>#text</td>
<td>3</td>
<td>文本内容</td>
</tr>
</tbody></table>
<ol>
<li><p>nodeName<br>元素的标签名，以大写形式表示,只读，不能写</p>
</li>
<li><p>nodeValue<br>Text文本节点或Comment注释节点的文本内容,可读写</p>
</li>
<li><p>nodeType（最有用）<br>该节点的类型，只读返回这个div的所有的元素节点</p>
<p>数字是调用nodeType返回的数字<br>元素节点 —— 1<br>属性节点 —— 2 （基本没用，class=“demo”就是一个属性节点）<br>文本节点 —— 3<br>注释节点 —— 8<br>document —— 9<br>DocumentFragment —— 11</p>
</li>
<li><p>attributes<br>Element 节点的属性集合</p>
<p>属性名不能改，属性值可以改，但是我们一般不用这种方法<br>我们一般用getAttribute和setAttribute去取 </p>
<p>节点的一个方法 </p>
<p>Node.hasChildNodes();——他有没有子节点，返回值是true或false</p>
</li>
</ol>
<h3 id="DOM的获取"><a href="#DOM的获取" class="headerlink" title="DOM的获取"></a>DOM的获取</h3><ol>
<li>获取对象</li>
<li>操作（修改）对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浏览器已经为我们提供 文档节点 对象这个对象是window属性</span></span><br><span class="line"><span class="comment">//可以在页面中直接使用，文档节点代表的是整个网页</span></span><br><span class="line">			</span><br><span class="line"><span class="comment">//获取到button对象</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">			</span><br><span class="line"><span class="comment">//修改按钮的文字</span></span><br><span class="line">btn.innerHTML = <span class="string">"I'm Button"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h3><p>通过document对象调用</p>
<ul>
<li>getElementById()<ul>
<li>通过id属性获取一个元素节点对象</li>
</ul>
</li>
<li>getElementsByTagName()<ul>
<li>通过标签名获取一组元素节点对象</li>
<li>返回一个类数组对象</li>
</ul>
</li>
<li>getElementsByName()<ul>
<li>通过name属性获取一组元素节点对象</li>
</ul>
</li>
</ul>
<p>对节点的增删改查 ()括号里面都不用写.或# 查 查看元素节点</p>
<p>document代表整个文档（如果给html标签上面再套一层标签就是document） </p>
<ol>
<li><p>document.getElementById()</p>
<p>元素id 在Ie8以下的浏览器，不区分id大小写，而且也返回匹配name属性的元素，通过id标识我们来选择这个元素，一一对应</p>
<p>除了id以外，其余选择出来的都是一组，很少用id选择器</p>
</li>
<li><p>document.getElementsByTagName() (主要)</p>
<p>标签名，这是一个类数组，最主流的用法，经常用</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"only"</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从dom开始，我们所学的一切系统给我们生成的成组的东西，基本上都是类数组<br>例加个[0]就选中了第一个div，如果不加0，那个div表示的是一个数组，设置背景颜色就会报错</p>
<ol start="3">
<li>getElementsByName(); //IE不支持需注意，只有部分标签name可生效（表单，表单元素，img，iframe），不是在所有的浏览器都能用——开发一般不用</li>
<li>.getElementsByClassName() // 类名 -&gt;缺点： ie8和ie8以下的ie版本中没有，可以多个class一起，不是所有浏览器都能用</li>
<li>.querySelector() // css选择器，只能选一个，在ie7和ie7以下的版本中没有 </li>
<li>.querySelectorAll() // css选择器，全选，选一组，在ie7和ie7以下的版本中没有</li>
</ol>
<p>.querySelectorAll()和.querySelector()选出来的元素不是实时的（是静态的），所以一般不用，其他的再怎么修改，跟原来的没有关系</p>
<p>id选择器不能太依赖，一般当顶级框架存在，在css中一般用class选择器<br>query是一个词条</p>
<h3 id="获取元素节点的子节点"><a href="#获取元素节点的子节点" class="headerlink" title="获取元素节点的子节点"></a>获取元素节点的子节点</h3><p>遍历节点树：(灵活，兼容好)——关系类的选择<br>parentNode → 父节点 (最顶端的parentNode为#document);<br>childNodes → 子节点们（直接的节点数）节点包括文本节点，属性节点<br>firstChild → 第一个子节点<br>lastChild → 最后一个子节点<br>nextSibling →后一个兄弟节点<br>previousSibling → 前一个兄弟节点</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"only"</span> <span class="attr">class</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            内容</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>]</span></span><br><span class="line">	a.childNodes.length</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="DOM接口"><a href="#DOM接口" class="headerlink" title="DOM接口"></a>DOM接口</h3><p>dom结构树代表的是一系列继承关系</p>
<p><img src="https://img2020.cnblogs.com/blog/1708982/202004/1708982-20200405191000886-1768397487.png" alt=""></p>
<p>Document和document的关系</p>
<p>document继承自HTMLDocument.prototype。<br>HTMLDocument.prototype继承自Document.prototype</p>
<h4 id="DOM方法定义区域"><a href="#DOM方法定义区域" class="headerlink" title="DOM方法定义区域"></a>DOM方法定义区域</h4><ol>
<li>getElementById方法定义在Document.prototype上，即Element节点上不能使用。 </li>
<li>getElementsByName方法定义在HTMLDocument.prototype上，即非html中的document以外不能使用(xml document,Element) </li>
<li>getElementsByTagName方法定义在Document.prototype 和 Element.prototype上</li>
<li>HTMLDocument.prototype定义了一些常用的属性，body,head,分别指代HTML文档中的<code>&lt;body&gt;&lt;head&gt;</code>标签。</li>
<li>Document.prototype上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代<code>&lt;html&gt;</code>元素</li>
<li>getElementsByClassName、querySelectorAll、querySelector在Document,Element类中均有定义</li>
</ol>
<h4 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h4><ol>
<li><p>增 </p>
<p>document.createElement(); //增加或创建元素节点（标签）——常见</p>
<p>在括号里面写什么字符串，就创建什么标签</p>
<p>document.body.appendChild(div) document.createTextNode(); //创建文本节点 document.createComment(); //创建注释节点 document.createDocumentFragment(); //创建文档碎片节点</p>
</li>
<li><p>插——剪切操作 </p>
<p>PARENTNODE.appendChild(); 可以理解成.push</p>
<p>PARENTNODE.insertBefore(a, b);一定是div先insert a，before b</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];</span><br><span class="line">div.appendChild(span)；</span><br><span class="line"><span class="comment">//把sapn插入div</span></span><br><span class="line"><span class="keyword">var</span> strong = <span class="built_in">document</span>.createElement(<span class="string">'strong'</span>);</span><br><span class="line">div.insertBefore(<span class="string">'strong'</span>, <span class="string">'span'</span>);</span><br><span class="line"><span class="comment">//span前面插入strong</span></span><br></pre></td></tr></table></figure>


<ol start="3">
<li><p>删 </p>
<p>parent.removeChild(); //就是被剪切出来了<br>child.remove(); //自尽，完全删除</p>
</li>
<li><p>替换</p>
<p> parent.replaceChild(new, origin); //用新的new去置换旧的origin</p>
</li>
</ol>
<h5 id="Element节点"><a href="#Element节点" class="headerlink" title="Element节点"></a>Element节点</h5><ul>
<li><p>Element节点的一些属性</p>
<p>innerHTML ==&gt; 可取，可写，可赋值 ，可写值的才能+=<br>面用innerHTML改变css行间样式</p>
<p>innerText ==&gt; 可取，可赋值 (老版本火狐不兼容) / textContent(火狐使用这个，老版本IE不好使)innerText可取可赋值赋值会覆盖掉（能覆盖标签）</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.innerHTML = <span class="string">"123"</span>；</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Element节点的一些方法</p>
<p> ele.setAttribute() //设置</p>
<p> ele.getAttribute(); //取这个值</p>
<p>行间属性可以设置系统没有的</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.setAttbutte(<span class="string">'class'</span>, <span class="string">'demo'</span>);<span class="comment">//修改</span></span><br><span class="line">div.getAttribute(<span class="string">'class'</span>)<span class="comment">//获取</span></span><br></pre></td></tr></table></figure>



<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><p>这一部分都是实战用的，考试面试一般不考<br>脚本化就是操作的意思 </p>
<h3 id="查看滚动条的滚动距离"><a href="#查看滚动条的滚动距离" class="headerlink" title="查看滚动条的滚动距离"></a>查看滚动条的滚动距离</h3><p>1、window.pageXOffset横向/pageYOffset纵向滚动条</p>
<p>IE8及IE8以下不兼容（IE9部分兼容）IE9以上能用<br>例：滚动条往下滚动了400px，求浏览器最顶端到滚动条滚动的位置的像素<br>答案400px+首屏像素（此时这个屏幕的底端距离整个网页的最顶端也是这样算）</p>
<p>2、IE8及IE8以下的使用方法 </p>
<p>1）document.body.scrollLeft/scrollTop——求横向距离和纵向距离 </p>
<p>2）document. documentElement.scrollLeft/scrollTop</p>
<p>上面两个兼容性比较混乱，其中一个有值，另外一个的值一定是0。这两个最好的用法是取两个值相加，因为不可能存在两个同时有值</p>
<p>如document.body.scrollLeft + document. documentElement.scrollLeft</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装兼容性方法（哪个浏览器都好用），求滚动轮滚动距离getScrollOffset()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetScrolloffset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.pageXoffsrt)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: <span class="built_in">window</span>.pageXoffset,</span><br><span class="line">            y: <span class="built_in">window</span>.pageYoffset</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            x: <span class="built_in">document</span>.body.scrollLeft + 		domcument.doumentElement.scrollLeft,</span><br><span class="line">            y: <span class="built_in">document</span>.body.scrollTop + 		domcument.doumentElement.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看视口的尺寸"><a href="#查看视口的尺寸" class="headerlink" title="查看视口的尺寸"></a>查看视口的尺寸</h3><p>可视区窗口就是编写的html文档可以看到的部分，不含菜单栏、地址栏、控制台 1、window.innerWidth/innerHeight可视区域的宽高 （加上 滚动条宽度 / 高度）<br>IE8及IE8以下不兼容 //w3c标准方法</p>
<p>注意渲染模式： </p>
<ol>
<li>标准模式：&lt;！DOCTYPE html&gt;是html5的（在emmet插件下html:5就出来了）<br>2怪异/混杂模式：试图去兼容之前的语法，去掉&lt;！DOCTYPE html&gt;这一行即可开启（向后兼容）</li>
<li>document.documentElement.clientWidth/clientHeight<br>标准模式下，任意浏览器都兼容 client是客户端的意思 </li>
<li>document.body.clientWidth/clientHeight<br>适用于怪异模式下的浏览器 </li>
<li>封装兼容性方法，返回浏览器视口尺寸getViewportOffset()</li>
</ol>
<p>document.compatMode是用于判断是怪异模式还是标准模式的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getViewportOffset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.innerWidth)&#123;</span><br><span class="line">        retuen &#123;</span><br><span class="line">            w: <span class="built_in">window</span>.innerWidth,</span><br><span class="line">            h: <span class="built_in">window</span>.innerHeight</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode === <span class="string">"BackCompat"</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                w: <span class="built_in">document</span>.body.clientWidth,</span><br><span class="line">                h: <span class="built_in">document</span>.body.clientHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                w: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">                h: <span class="built_in">document</span>.documentElement.clientHeight</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查看元素的几何尺寸"><a href="#查看元素的几何尺寸" class="headerlink" title="查看元素的几何尺寸"></a>查看元素的几何尺寸</h3><p>domEle.getBoundingClientRect(); //这是es5.0的方法，但是只用了解</p>
<p>求得是四个边和窗口之间的像素距离，right是右边离document的边有200px ，也可以理解成求的是左上点和右下点的位置 </p>
<p>2、兼容性很好</p>
<p>3、该方法返回一个对象，对象里面有left,top,right,bottom等属性。left和top代表该元素左上角的X和Y坐标，right和bottom代表元素右下角的X和Y坐标 </p>
<p>4、height和width属性老版本IE并未实现<br>在老版本的ie里面，利用右侧边减左侧面解决</p>
<p>5、返回的结果并不是“实时的”</p>
<h3 id="查看元素的尺寸"><a href="#查看元素的尺寸" class="headerlink" title="查看元素的尺寸"></a>查看元素的尺寸</h3><p>dom.offsetWidth，dom.offsetHeight<br>求得值是包括padding的</p>
<p>dom.offsetWidth和domEle.getBoundingClientRect();出现的值是一样的，求的值都是padding+content（视觉尺寸），可以被代替。右上是间接的求这个div的宽高</p>
<h3 id="查看元素的位置"><a href="#查看元素的位置" class="headerlink" title="查看元素的位置"></a>查看元素的位置</h3><p>1、dom.offsetLeft, dom.offsetTop<br>对于无定位父级的元素，返回相对文档的坐标。<br>对于有定位父级的元素，返回相对于最近的有定位的父级的坐标。(无论是 left 还是margin-left等都是距离。 )</p>
<p>例.offsetLeft忽略自身是不是定位元素，求出来的是这个元素距离自己有定位的父级元素的距离，不管距离是margin生成还是定位生成或者是其他方法（圆形，五角星都是这样）</p>
<p>dom.offsetParent<br>返回最近的有定位的父级，如无，返回body, body.offsetParent 返回null<br>这个方法能求有定位的父级</p>
<h3 id="滚动条滚动"><a href="#滚动条滚动" class="headerlink" title="滚动条滚动"></a>滚动条滚动</h3><p>window上有三个方法scroll(), scrollTo(),两个功能一样，</p>
<p>scrollBy();累加滚动距离</p>
<p>scroll(x，y), scrollTo(x，y),功能是一样的，里面能填两个参数<br>scroll(x轴滚动条的距离，y轴滚动条的距离)，里面的xy可以填负数</p>
<p>scrollBy(x，y);是累加滚动距离，填负数就往上滚动</p>
<p>2、三个方法功能类似，用法都是将x,y坐标传入。即实现让滚动轮滚动到当前位置。 </p>
<p>3、区别：scrollBy()会在之前的数据基础之上做累加。</p>
<p>eg：利用scrollBy() 快速阅读的功能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.scroll(<span class="number">0</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//做个自动翻页的阅读（当点击start就自动阅读）</span></span><br><span class="line"><span class="keyword">var</span> start = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> stop = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> timer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> key = <span class="literal">true</span>;</span><br><span class="line">start.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(key) &#123;</span><br><span class="line">        timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">window</span>.scrollBy(<span class="number">0</span>, num);</span><br><span class="line">        &#125;,<span class="number">100</span>);</span><br><span class="line">        key = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">stop.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">    key = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="脚本化CSS"><a href="#脚本化CSS" class="headerlink" title="脚本化CSS"></a>脚本化CSS</h2><p>dom不能操作css，是间接操作css，这一部分需要记下</p>
<h3 id="读写元素css属性（间接控制）"><a href="#读写元素css属性（间接控制）" class="headerlink" title="读写元素css属性（间接控制）"></a>读写元素css属性（间接控制）</h3><ol>
<li>dom.style.prop //常用，只有这个可读可写，其余只能读 </li>
<li>可读写行间样式，没有兼容性问题，碰到float这样的关键字属性，前面应加css(行间样式以外没用)<br> eg:float — &gt; cssFloat </li>
<li>符合属性必须拆解（建议），组合单词变成小驼峰式写法 </li>
<li>写入的值必须是字符串格式</li>
</ol>
<p>CSSStyleDeclaration是css样式表声明（类数组，有索引类的属性），把你能够用的所有的css都展示出来了，里面不填写就有没有值是空串。<br>可以用<code>div.style[‘width’]</code>拿出属性，也可以用<code>div.style.width</code>，效果一样。<br>在js访问属性的时候没有-杠的形式，不能写background-color，要写小驼峰。<br>不在html文件里面写的值也可以利用js调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.style.borderRadius=”<span class="number">50</span>”;</span><br></pre></td></tr></table></figure>

<h3 id="查询计算样式"><a href="#查询计算样式" class="headerlink" title="查询计算样式"></a>查询计算样式</h3><ol>
<li><p>window.getComputedStyle(ele,null); //原生底层的方法。</p>
<p>展示权重最高的<br>获取伪元素的方法：<code>window.getComputedStyle(ele,null);</code>括号里面要填两个东西，第一个ele是填的是你要获取谁，第二个先填写null（null解决的就是伪元素的问题，用它可以获取伪元素的样式表）。</p>
</li>
<li><p>计算样式只读，不可以写入</p>
</li>
<li><p>返回的计算样式的值都是绝对值，没有相对单位 </p>
</li>
<li><p>IE8 及 IE8以下不兼容</p>
</li>
</ol>
<h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>1、JSON是一种传输数据的格式（以对象为样板，本质上就是对象，但用途有区别，对象就是本地用的，json是用来传输的） </p>
<p>2、JSON.parse(); string — &gt; json </p>
<p>3、JSON.stringify(); json — &gt; string</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj &#123;</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"ting"</span>,</span><br><span class="line">    <span class="string">"age"</span> : <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="comment">//变成字符串形式的json</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(str);</span><br><span class="line"><span class="comment">//变回为obj对象</span></span><br></pre></td></tr></table></figure>

<h2 id="DOM-Tree-dom树"><a href="#DOM-Tree-dom树" class="headerlink" title="DOM Tree(dom树)"></a>DOM Tree(dom树)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">绘制dom树，符合深度优先（纵向）原则，比如先看head → title → meta →body → div → strong → span。</span><br></pre></td></tr></table></figure>

<p>dom树是节点解析，dom树解析完毕代表dom数所有的节点解析完毕，不代表加载（下载完毕）完毕。如看到img标签就放到dom树上，然后同时下载。</p>
<p>dom树形成完了以后，就等css树形成【cssTree也是深度优先原则。】。<br>domTree + cssTree = randerTree，randerTree形成以后才，渲染引擎才会绘制页面，domTree改变，randerTree也会改变，会重排，影响效率,要尽量避免重排。</p>
<p>randerTree触发重排（reflow）的情况：dom节点的删除，添加，dom节点的宽高变化，位置变化，display none ==&gt; block，offsetWidth，offsetLeft<br>repaint重绘：效率也比较低，效率影响较小。触发情况：改颜色，图片</p>
<h2 id="异步加载js"><a href="#异步加载js" class="headerlink" title="异步加载js"></a>异步加载js</h2><p>js是单线程的，会阻断HTML，css加载（因为js会修改html和css一起加载会乱），所以是同步加载js。先下载js，再下载HTML和css。常规来说js是同步加载的，所以我们讲讲js异步加载的情况</p>
<p> 一、js加载的缺点：加载工具方法没必要阻塞文档，过得js加载会影响页面效率，一旦网速不好，那么整个网站将等待js加载而不进行后续渲染等工作。 </p>
<p>二、有些工具方法需要按需加载，用到再加载，不用不加载。 </p>
<p>三、javascript 异步加载的三种方案 </p>
<p>1、defer 异步加载，但要等到dom文档全部解析完（dom树生成完）才会被执行。只有IE能用。<br>dom文档全部解析完，不代表整个页面加载完 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer=<span class="string">"defer"</span> src=<span class="string">"../.. .js"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>2、async 异步加载，加载完就执行，async只能加载外部脚本，不能把js写在script 标签里。ie9以上可以用，w3c标准 1和2 执行时也不阻塞页面 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script aysnc=<span class="string">"aysnc"</span> src=<span class="string">"../.. .js"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>3、创建script，插入到DOM中，加载完毕后callBack（按需加载，方便）→常用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ladScript</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    scripy.type = <span class="string">"text/javscript"</span>;</span><br><span class="line">    <span class="keyword">if</span>(script.readyState) &#123;</span><br><span class="line">        script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(script.readyState == <span class="string">"complete"</span> || script.readyState == <span class="string">"loaded"</span>) &#123;</span><br><span class="line">                tools[callback]()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            toole[callback]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = url;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadScript(<span class="string">'demo.js'</span>, test);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步加载demo.js</span></span><br><span class="line"><span class="comment">//demo</span></span><br><span class="line"><span class="keyword">var</span> tools = &#123;</span><br><span class="line">    test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>onload事件会在整个页面加载完成之后才触发</p>
<p>为window绑定一个onload事件</p>
<p>该事件对应的响应函数将会在页面加载完成之后执行，</p>
<p>这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//获取id为btn的按钮</span></span><br><span class="line">	<span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//为按钮绑定一个单击响应函数</span></span><br><span class="line">	btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"hello"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="js加载时间线"><a href="#js加载时间线" class="headerlink" title="js加载时间线"></a>js加载时间线</h2><p>js加载时间线（可以理解成浏览器加载时间线）背</p>
<p>js加载时间线：依据js出生的那一刻起，记录了一系列浏览器按照顺序做的事（就是一个执行顺序） js时间线步骤（创建document对象==&gt;文档解析完==&gt;文档解析完加载完执行完） </p>
<ol>
<li>创建Document对象，开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’。 </li>
<li>遇到link外部css，创建线程，进行异步加载，并继续解析文档。 </li>
<li>遇到script外部js，并且没有设置async、defer，浏览器同步加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。 </li>
<li>遇到script外部js，并且设置有async、defer，浏览器创建线程异步加载，并继续解析文档。<br>对于async属性的脚本，脚本加载完成后立即执行。（异步禁止使用document.write()，因为当你整个文档解析到差不多，再调用document.write()，会把之前所有的文档流都清空，用它里面的文档代替） </li>
<li>遇到img等（带有src），先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。 看到标签直接生产dom树，不用等着img加载完scr。 </li>
<li>当文档解析完成（domTree建立完毕，不是加载完毕），document.readyState = ‘interactive’。 </li>
<li>文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async的不同,但同样禁止使用document.write()）; </li>
<li>document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。 </li>
<li>当所有async的脚本加载完成并执行后、img等加载完成后（页面所有的都执行加载完之后），document.readyState = ‘complete’，window对象触发load事件。 </li>
<li>从此，以异步响应方式处理用户输入、网络事件等。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload</span><br><span class="line"><span class="comment">//最后解析，慢，不推荐</span></span><br><span class="line"><span class="comment">//只要有一个图片没加载完，window.onload就不能用，所以效率非常低下</span></span><br><span class="line">script标签这样写在上面。又能操作div，又能dom解析完就处理，效率很高。但是最好还是写在最下面‘</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    	<span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">  		<span class="built_in">console</span>.log(div);</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件就是文档或浏览器窗口中发生的特定交互瞬间</p>
<p>JS与HTML交互是通过事件</p>
<p>如：点击鼠标、敲击键盘发生的交互</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取按钮对象</span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line">			</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 可以为按钮的对应事件绑定处理函数的形式来响应事件</span></span><br><span class="line"><span class="comment">* 	这样当事件被触发时，其对应的函数将会被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">			</span><br><span class="line"><span class="comment">//绑定一个单击事件</span></span><br><span class="line"><span class="comment">//像这种为单击事件绑定的函数，我们称为单击响应函数</span></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"你还点~~~"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="如何绑定事件"><a href="#如何绑定事件" class="headerlink" title="如何绑定事件"></a>如何绑定事件</h3><p>1、<code>ele.onxxx = function (event) {}</code></p>
<p>兼容性很好，但是一个元素只能绑定一个事件处理程序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByYagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"点击事件"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//div.onclicck就叫做可以被点击的事件（绑定事件类型），</span></span><br><span class="line"><span class="comment">//function()&#123;&#125;是反馈，一旦事件被触发，就要执行function里面的函数（绑定的是一个事件处理函数）</span></span><br></pre></td></tr></table></figure>

<p>写在行内基本等同于写在HTML行间上，如下</p>
<p>onclick=”consolo.log(‘a’)”是句柄的绑定方式，写在行间不用写function(){}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">"background-color:red"</span> onclick=<span class="string">"console.log("</span>点击事件<span class="string">")"</span></span><br></pre></td></tr></table></figure>



<p>2、ele.addEventListener(type, fn, false);里面可以填三个参数</p>
<p>IE9以下不兼容，可以为一个事件绑定多个处理程序 </p>
<p>div.addEventListener（’事件类型’，处理函数，false）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByYagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.addEventListener(<span class="string">'clinck'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'点击事件'</span>)；</span><br><span class="line">&#125;， <span class="literal">false</span>)；</span><br><span class="line"><span class="comment">//div.addEventListener（‘click’，function()&#123;&#125;，false）</span></span><br><span class="line"><span class="comment">//function()&#123;&#125; 是函数引用，和外面定义一个function test()&#123;&#125;直接写test是一样的</span></span><br></pre></td></tr></table></figure>

<p>若console.log两个都是(‘a‘)打印出来是两个a。这是两个处理函数，是两个地址</p>
<p>如果打印同一个地址事件，则打印一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByYagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line">div.addEventListener(<span class="string">'clinck'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'点击事件'</span>)；</span><br><span class="line">&#125;， <span class="literal">false</span>)；</span><br><span class="line">div.addEventListener(<span class="string">'clinck'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'点击事件'</span>)；</span><br><span class="line">&#125;， <span class="literal">false</span>)；</span><br><span class="line"><span class="comment">//打印两次，因为function是两个不同</span></span><br><span class="line">div.addEventListener(<span class="string">'clinck'</span>, test， <span class="literal">false</span>)；</span><br><span class="line">div.addEventListener(<span class="string">'clinck'</span>, test， <span class="literal">false</span>)；</span><br><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'点击事件'</span>)；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印一次，同一个地址事件</span></span><br></pre></td></tr></table></figure>

<p>3、<code>ele.attachEvent(‘on’ + type, fn);</code></p>
<p><code>IE</code>独有，一个事件同样可以绑定多个处理程序，同一个函数绑定多次都可以<br><code>div.attachEvent(‘on’ + 事件类型，处理函数);</code><br><code>div.attachEvent(‘onclick’ ，function（）{});</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定事件出现在循环里面（用到i），考虑是否形成闭包，用立即执行函数来写</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">	&lt;li&gt;2&lt;/</span>li&gt;</span><br><span class="line">	&lt;li&gt;<span class="number">3</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.getElementsByYagName(<span class="string">'li'</span>)[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">var</span> len = liCol.length;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">            liColi[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(i);</span><br><span class="line">            &#125;, <span class="literal">false</span>);</span><br><span class="line">        &#125;(i))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行环境this"><a href="#运行环境this" class="headerlink" title="运行环境this"></a>运行环境this</h3><p>1、ele.onxxx = function (event) {}<br>程序this指向是dom元素本身（指向自己）</p>
<p>2、obj.addEventListener(type, fn, false);<br>程序this指向是dom元素本身（指向自己）</p>
<p>3、obj.attachEvent(‘on’ + type, fn); 程序this指向window</p>
<p>封装兼容性的 addEvent(elem, type, handle);方法（必须会）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">elem, type, handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elem.addEventListener) &#123;</span><br><span class="line">        elem.addEventListener(type, handle, <span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(elem.attachEvent)&#123;</span><br><span class="line">        elem.attchEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            handle.call(elem);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        elem[<span class="string">'on'</span> + type] = handle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解除事件处理程序</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%89%8D%E7%AB%AF%E6%80%BB%E7%BB%93/" rel="tag"># 前端总结</a>
              <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/14/04CSS%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" rel="prev" title="CSS基础总结笔记">
      <i class="fa fa-chevron-left"></i> CSS基础总结笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/23/06EC6%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="next" title="EC6的主要知识点">
      EC6的主要知识点 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#初识-JavaScript"><span class="nav-number">1.</span> <span class="nav-text">初识 JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器执行JS过程"><span class="nav-number">1.1.</span> <span class="nav-text">浏览器执行JS过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript的组成"><span class="nav-number">1.2.</span> <span class="nav-text">JavaScript的组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript三种方式"><span class="nav-number">1.3.</span> <span class="nav-text">JavaScript三种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript输入输出语句"><span class="nav-number">1.4.</span> <span class="nav-text">JavaScript输入输出语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标识符"><span class="nav-number">2.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">3.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本语法"><span class="nav-number">4.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语句基本规则"><span class="nav-number">4.1.</span> <span class="nav-text">语句基本规则</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码块"><span class="nav-number">4.1.1.</span> <span class="nav-text">代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码错误"><span class="nav-number">4.1.2.</span> <span class="nav-text">代码错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算数运算符"><span class="nav-number">4.2.</span> <span class="nav-text">算数运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运算操作符"><span class="nav-number">4.2.1.</span> <span class="nav-text">运算操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较运算符"><span class="nav-number">4.2.2.</span> <span class="nav-text">比较运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑运算符"><span class="nav-number">4.2.3.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件运算符"><span class="nav-number">4.2.4.</span> <span class="nav-text">条件运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件语句"><span class="nav-number">4.3.</span> <span class="nav-text">条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#If语句"><span class="nav-number">4.3.1.</span> <span class="nav-text">If语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#switch-case"><span class="nav-number">4.3.2.</span> <span class="nav-text">switch case</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环语句"><span class="nav-number">4.4.</span> <span class="nav-text">循环语句</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for循环"><span class="nav-number">4.4.1.</span> <span class="nav-text">for循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#while循环"><span class="nav-number">4.4.2.</span> <span class="nav-text">while循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#do-while循环"><span class="nav-number">4.4.3.</span> <span class="nav-text">do while循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#back"><span class="nav-number">4.4.4.</span> <span class="nav-text">back</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#continue"><span class="nav-number">4.4.5.</span> <span class="nav-text">continue</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据类型"><span class="nav-number"></span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进制赋值"><span class="nav-number">1.</span> <span class="nav-text">进制赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用值"><span class="nav-number">2.</span> <span class="nav-text">引用值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">2.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象object"><span class="nav-number">2.2.</span> <span class="nav-text">对象object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typeof操作符"><span class="nav-number">2.3.</span> <span class="nav-text">typeof操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">3.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Number-mix"><span class="nav-number">3.0.1.</span> <span class="nav-text">Number(mix)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parseInt-string-radix"><span class="nav-number">3.0.2.</span> <span class="nav-text">parseInt(string,radix)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#parseFloat-string"><span class="nav-number">3.0.3.</span> <span class="nav-text">parseFloat(string)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toString方法"><span class="nav-number">3.0.4.</span> <span class="nav-text">toString方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-mix-函数"><span class="nav-number">3.0.5.</span> <span class="nav-text">String(mix)函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Boolean-mix"><span class="nav-number">3.0.6.</span> <span class="nav-text">Boolean(mix)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐式类型转换"><span class="nav-number">3.1.</span> <span class="nav-text">隐式类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#isNaN"><span class="nav-number">3.1.1.</span> <span class="nav-text">isNaN ()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#–、-、-和"><span class="nav-number">3.1.2.</span> <span class="nav-text">++&#x2F;–、 +&#x2F;- 、*和%</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#amp-amp-！"><span class="nav-number">3.1.3.</span> <span class="nav-text">&amp;&amp;      ||     ！</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lt-gt-lt-gt"><span class="nav-number">3.1.4.</span> <span class="nav-text">&lt; &gt; &lt;&#x3D; &gt;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#、"><span class="nav-number">3.1.5.</span> <span class="nav-text">&#x3D;&#x3D;、 !&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不发生类型转换"><span class="nav-number">3.2.</span> <span class="nav-text">不发生类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数function"><span class="nav-number">4.</span> <span class="nav-text">函数function</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数表达式"><span class="nav-number">4.2.</span> <span class="nav-text">函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数"><span class="nav-number">4.3.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#返回值return"><span class="nav-number">4.4.</span> <span class="nav-text">返回值return</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js运行三部曲"><span class="nav-number">5.</span> <span class="nav-text">js运行三部曲</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#预编译"><span class="nav-number">5.1.</span> <span class="nav-text">预编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（函数）预编译的四部曲"><span class="nav-number">5.2.</span> <span class="nav-text">（函数）预编译的四部曲</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局的预编译三部曲"><span class="nav-number">5.2.1.</span> <span class="nav-text">全局的预编译三部曲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先生成GO还是AO"><span class="nav-number">5.2.2.</span> <span class="nav-text">先生成GO还是AO?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域精解"><span class="nav-number">5.3.</span> <span class="nav-text">作用域精解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#立即执行函数"><span class="nav-number">5.4.</span> <span class="nav-text">立即执行函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">6.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包的作用"><span class="nav-number">6.1.</span> <span class="nav-text">闭包的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包的防范"><span class="nav-number">6.2.</span> <span class="nav-text">闭包的防范</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-number">7.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的分类"><span class="nav-number">7.1.</span> <span class="nav-text">对象的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性的增、删、改、查"><span class="nav-number">7.2.</span> <span class="nav-text">属性的增、删、改、查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的创建方法"><span class="nav-number">7.3.</span> <span class="nav-text">对象的创建方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数内部原理"><span class="nav-number">7.4.</span> <span class="nav-text">构造函数内部原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数注意点"><span class="nav-number">7.4.1.</span> <span class="nav-text">构造函数注意点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装类"><span class="nav-number">7.5.</span> <span class="nav-text">包装类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象枚举"><span class="nav-number">7.6.</span> <span class="nav-text">对象枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收（GC）"><span class="nav-number">7.7.</span> <span class="nav-text">垃圾回收（GC）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型"><span class="nav-number">8.</span> <span class="nav-text">原型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链"><span class="nav-number">8.1.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-create-原型"><span class="nav-number">8.2.</span> <span class="nav-text">Object.create(原型);</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call-apply"><span class="nav-number">9.</span> <span class="nav-text">call&#x2F;apply</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">10.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命名空间"><span class="nav-number">10.1.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现链式调用"><span class="nav-number">10.2.</span> <span class="nav-text">实现链式调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性的表示方法"><span class="nav-number">10.3.</span> <span class="nav-text">属性的表示方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的枚举"><span class="nav-number">10.4.</span> <span class="nav-text">对象的枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this"><span class="nav-number">11.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arguments"><span class="nav-number">12.</span> <span class="nav-text">arguments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#克隆"><span class="nav-number">13.</span> <span class="nav-text">克隆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#浅层克隆"><span class="nav-number">13.1.</span> <span class="nav-text">浅层克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度克隆的步骤"><span class="nav-number">13.2.</span> <span class="nav-text">深度克隆的步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三目运算符"><span class="nav-number">14.</span> <span class="nav-text">三目运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组-1"><span class="nav-number">15.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组常用的方法"><span class="nav-number">15.1.</span> <span class="nav-text">数组常用的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不改变原数组"><span class="nav-number">15.2.</span> <span class="nav-text">不改变原数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组的遍历"><span class="nav-number">15.3.</span> <span class="nav-text">数组的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组去重"><span class="nav-number">15.4.</span> <span class="nav-text">数组去重</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类数组"><span class="nav-number">16.</span> <span class="nav-text">类数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#日期对象"><span class="nav-number">17.</span> <span class="nav-text">日期对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定时器"><span class="nav-number">17.1.</span> <span class="nav-text">定时器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try…catch防止我们报错"><span class="nav-number">18.</span> <span class="nav-text">try…catch防止我们报错</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误信息"><span class="nav-number">19.</span> <span class="nav-text">错误信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#es5-0严格模式"><span class="nav-number">20.</span> <span class="nav-text">es5.0严格模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则表达式"><span class="nav-number">21.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础语法"><span class="nav-number">21.1.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#正则表达式字面量（推荐）"><span class="nav-number">21.1.1.</span> <span class="nav-text">正则表达式字面量（推荐）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数new-RegExp"><span class="nav-number">21.1.2.</span> <span class="nav-text">构造函数new RegExp();</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RegExp-对象属性"><span class="nav-number">21.1.2.1.</span> <span class="nav-text">RegExp 对象属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RegExp-对象方法"><span class="nav-number">21.1.2.2.</span> <span class="nav-text">RegExp 对象方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#修饰符"><span class="nav-number">21.1.3.</span> <span class="nav-text">修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模式"><span class="nav-number">21.1.4.</span> <span class="nav-text">模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#元字符"><span class="nav-number">21.1.5.</span> <span class="nav-text">元字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#量词"><span class="nav-number">21.1.6.</span> <span class="nav-text">量词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表达式"><span class="nav-number">21.1.7.</span> <span class="nav-text">表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#string方法"><span class="nav-number">21.1.8.</span> <span class="nav-text">string方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#补充"><span class="nav-number">21.2.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM"><span class="nav-number">22.</span> <span class="nav-text">DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#节点"><span class="nav-number">22.1.</span> <span class="nav-text">节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用节点分类"><span class="nav-number">22.1.1.</span> <span class="nav-text">常用节点分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点的类型"><span class="nav-number">22.1.2.</span> <span class="nav-text">节点的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点的四个属性"><span class="nav-number">22.1.3.</span> <span class="nav-text">节点的四个属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM的获取"><span class="nav-number">22.2.</span> <span class="nav-text">DOM的获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取元素节点"><span class="nav-number">22.3.</span> <span class="nav-text">获取元素节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取元素节点的子节点"><span class="nav-number">22.4.</span> <span class="nav-text">获取元素节点的子节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM接口"><span class="nav-number">22.5.</span> <span class="nav-text">DOM接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM方法定义区域"><span class="nav-number">22.5.1.</span> <span class="nav-text">DOM方法定义区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM基本操作"><span class="nav-number">22.5.2.</span> <span class="nav-text">DOM基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Element节点"><span class="nav-number">22.5.2.1.</span> <span class="nav-text">Element节点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM操作"><span class="nav-number">23.</span> <span class="nav-text">DOM操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查看滚动条的滚动距离"><span class="nav-number">23.1.</span> <span class="nav-text">查看滚动条的滚动距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看视口的尺寸"><span class="nav-number">23.2.</span> <span class="nav-text">查看视口的尺寸</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看元素的几何尺寸"><span class="nav-number">23.3.</span> <span class="nav-text">查看元素的几何尺寸</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看元素的尺寸"><span class="nav-number">23.4.</span> <span class="nav-text">查看元素的尺寸</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看元素的位置"><span class="nav-number">23.5.</span> <span class="nav-text">查看元素的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#滚动条滚动"><span class="nav-number">23.6.</span> <span class="nav-text">滚动条滚动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#脚本化CSS"><span class="nav-number">24.</span> <span class="nav-text">脚本化CSS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读写元素css属性（间接控制）"><span class="nav-number">24.1.</span> <span class="nav-text">读写元素css属性（间接控制）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询计算样式"><span class="nav-number">24.2.</span> <span class="nav-text">查询计算样式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#json"><span class="nav-number">25.</span> <span class="nav-text">json</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM-Tree-dom树"><span class="nav-number">26.</span> <span class="nav-text">DOM Tree(dom树)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异步加载js"><span class="nav-number">27.</span> <span class="nav-text">异步加载js</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#js加载时间线"><span class="nav-number">28.</span> <span class="nav-text">js加载时间线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件"><span class="nav-number">29.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何绑定事件"><span class="nav-number">29.1.</span> <span class="nav-text">如何绑定事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行环境this"><span class="nav-number">29.2.</span> <span class="nav-text">运行环境this</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ting"
      src="/images/ting.png">
  <p class="site-author-name" itemprop="name">Ting</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/TINGCYGF" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TINGCYGF" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1127163160@QQ.com" title="E-Mail → 1127163160@QQ.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ting</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
